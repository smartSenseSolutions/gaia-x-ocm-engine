"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsMap = exports.DateParser = exports.MetadataTransformer = exports.RecordTransformer = void 0;
const class_transformer_1 = require("class-transformer");
const class_validator_1 = require("class-validator");
const luxon_1 = require("luxon");
const credentialMetadataTypes_1 = require("../modules/credentials/repository/credentialMetadataTypes");
const Metadata_1 = require("../storage/Metadata");
const JsonTransformer_1 = require("./JsonTransformer");
/**
 * Decorator that transforms json to and from corresponding record.
 *
 * @example
 * class Example {
 *   RecordTransformer(Service)
 *   private services: Record<string, Service>;
 * }
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function RecordTransformer(Class) {
    return class_transformer_1.Transform(({ value, type }) => {
        switch (type) {
            case class_transformer_1.TransformationType.CLASS_TO_PLAIN:
                return Object.entries(value).reduce((accumulator, [key, attribute]) => (Object.assign(Object.assign({}, accumulator), { [key]: JsonTransformer_1.JsonTransformer.toJSON(attribute) })), {});
            case class_transformer_1.TransformationType.PLAIN_TO_CLASS:
                return Object.entries(value).reduce((accumulator, [key, attribute]) => (Object.assign(Object.assign({}, accumulator), { [key]: JsonTransformer_1.JsonTransformer.fromJSON(attribute, Class) })), {});
            default:
                return value;
        }
    });
}
exports.RecordTransformer = RecordTransformer;
/*
 * Decorator that transforms to and from a metadata instance.
 *
 * @todo remove the conversion at 0.1.0 release via a migration script
 */
function MetadataTransformer() {
    return class_transformer_1.Transform(({ value, type }) => {
        if (type === class_transformer_1.TransformationType.CLASS_TO_PLAIN) {
            return Object.assign({}, value.data);
        }
        if (type === class_transformer_1.TransformationType.PLAIN_TO_CLASS) {
            const { requestMetadata, schemaId, credentialDefinitionId } = value, rest = __rest(value, ["requestMetadata", "schemaId", "credentialDefinitionId"]);
            const metadata = new Metadata_1.Metadata(rest);
            if (requestMetadata)
                metadata.add(credentialMetadataTypes_1.CredentialMetadataKeys.IndyRequest, Object.assign({}, value.requestMetadata));
            if (schemaId)
                metadata.add(credentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, { schemaId: value.schemaId });
            if (credentialDefinitionId)
                metadata.add(credentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, { credentialDefinitionId: value.credentialDefinitionId });
            return metadata;
        }
        if (type === class_transformer_1.TransformationType.CLASS_TO_CLASS) {
            return value;
        }
    });
}
exports.MetadataTransformer = MetadataTransformer;
/*
 * Function that parses date from multiple formats
 * including SQL formats.
 */
function DateParser(value) {
    const parsedDate = new Date(value);
    if (parsedDate instanceof Date && !isNaN(parsedDate.getTime())) {
        return parsedDate;
    }
    const luxonDate = luxon_1.DateTime.fromSQL(value);
    if (luxonDate.isValid) {
        return new Date(luxonDate.toString());
    }
    return new Date();
}
exports.DateParser = DateParser;
/**
 * Checks if a given value is a Map
 */
function IsMap(validationOptions) {
    return class_validator_1.ValidateBy({
        name: 'isMap',
        validator: {
            validate: (value) => value instanceof Map,
            defaultMessage: class_validator_1.buildMessage((eachPrefix) => eachPrefix + '$property must be a Map', validationOptions),
        },
    }, validationOptions);
}
exports.IsMap = IsMap;
//# sourceMappingURL=transformers.js.map
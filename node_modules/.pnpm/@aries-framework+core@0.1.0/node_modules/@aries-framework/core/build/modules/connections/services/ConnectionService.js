"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionService = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../../agent/AgentConfig");
const EventEmitter_1 = require("../../../agent/EventEmitter");
const constants_1 = require("../../../constants");
const SignatureDecoratorUtils_1 = require("../../../decorators/signature/SignatureDecoratorUtils");
const error_1 = require("../../../error");
const JsonTransformer_1 = require("../../../utils/JsonTransformer");
const MessageValidator_1 = require("../../../utils/MessageValidator");
const ConnectionEvents_1 = require("../ConnectionEvents");
const errors_1 = require("../errors");
const messages_1 = require("../messages");
const models_1 = require("../models");
const ConnectionRecord_1 = require("../repository/ConnectionRecord");
const ConnectionRepository_1 = require("../repository/ConnectionRepository");
let ConnectionService = class ConnectionService {
    constructor(wallet, config, connectionRepository, eventEmitter) {
        this.wallet = wallet;
        this.config = config;
        this.connectionRepository = connectionRepository;
        this.eventEmitter = eventEmitter;
        this.logger = config.logger;
    }
    /**
     * Create a new connection record containing a connection invitation message
     *
     * @param config config for creation of connection and invitation
     * @returns new connection record
     */
    async createInvitation(config) {
        var _a, _b, _c;
        // TODO: public did
        const connectionRecord = await this.createConnection({
            role: models_1.ConnectionRole.Inviter,
            state: models_1.ConnectionState.Invited,
            alias: config === null || config === void 0 ? void 0 : config.alias,
            routing: config.routing,
            autoAcceptConnection: config === null || config === void 0 ? void 0 : config.autoAcceptConnection,
            multiUseInvitation: (_a = config.multiUseInvitation) !== null && _a !== void 0 ? _a : false,
        });
        const { didDoc } = connectionRecord;
        const [service] = didDoc.didCommServices;
        const invitation = new messages_1.ConnectionInvitationMessage({
            label: (_b = config === null || config === void 0 ? void 0 : config.myLabel) !== null && _b !== void 0 ? _b : this.config.label,
            recipientKeys: service.recipientKeys,
            serviceEndpoint: service.serviceEndpoint,
            routingKeys: service.routingKeys,
            imageUrl: (_c = config === null || config === void 0 ? void 0 : config.myImageUrl) !== null && _c !== void 0 ? _c : this.config.connectionImageUrl,
        });
        connectionRecord.invitation = invitation;
        await this.connectionRepository.update(connectionRecord);
        this.eventEmitter.emit({
            type: ConnectionEvents_1.ConnectionEventTypes.ConnectionStateChanged,
            payload: {
                connectionRecord: connectionRecord,
                previousState: null,
            },
        });
        return { connectionRecord: connectionRecord, message: invitation };
    }
    /**
     * Process a received invitation message. This will not accept the invitation
     * or send an invitation request message. It will only create a connection record
     * with all the information about the invitation stored. Use {@link ConnectionService.createRequest}
     * after calling this function to create a connection request.
     *
     * @param invitation the invitation message to process
     * @returns new connection record.
     */
    async processInvitation(invitation, config) {
        const connectionRecord = await this.createConnection({
            role: models_1.ConnectionRole.Invitee,
            state: models_1.ConnectionState.Invited,
            alias: config === null || config === void 0 ? void 0 : config.alias,
            theirLabel: invitation.label,
            autoAcceptConnection: config === null || config === void 0 ? void 0 : config.autoAcceptConnection,
            routing: config.routing,
            invitation,
            imageUrl: invitation.imageUrl,
            tags: {
                invitationKey: invitation.recipientKeys && invitation.recipientKeys[0],
            },
            multiUseInvitation: false,
        });
        await this.connectionRepository.update(connectionRecord);
        this.eventEmitter.emit({
            type: ConnectionEvents_1.ConnectionEventTypes.ConnectionStateChanged,
            payload: {
                connectionRecord: connectionRecord,
                previousState: null,
            },
        });
        return connectionRecord;
    }
    /**
     * Create a connection request message for the connection with the specified connection id.
     *
     * @param connectionId the id of the connection for which to create a connection request
     * @param config config for creation of connection request
     * @returns outbound message containing connection request
     */
    async createRequest(connectionId, config) {
        var _a, _b;
        const connectionRecord = await this.connectionRepository.getById(connectionId);
        connectionRecord.assertState(models_1.ConnectionState.Invited);
        connectionRecord.assertRole(models_1.ConnectionRole.Invitee);
        const connectionRequest = new messages_1.ConnectionRequestMessage({
            label: (_a = config === null || config === void 0 ? void 0 : config.myLabel) !== null && _a !== void 0 ? _a : this.config.label,
            did: connectionRecord.did,
            didDoc: connectionRecord.didDoc,
            imageUrl: (_b = config === null || config === void 0 ? void 0 : config.myImageUrl) !== null && _b !== void 0 ? _b : this.config.connectionImageUrl,
        });
        await this.updateState(connectionRecord, models_1.ConnectionState.Requested);
        return {
            connectionRecord: connectionRecord,
            message: connectionRequest,
        };
    }
    /**
     * Process a received connection request message. This will not accept the connection request
     * or send a connection response message. It will only update the existing connection record
     * with all the new information from the connection request message. Use {@link ConnectionService.createResponse}
     * after calling this function to create a connection response.
     *
     * @param messageContext the message context containing a connection request message
     * @returns updated connection record
     */
    async processRequest(messageContext, routing) {
        const { message, recipientVerkey, senderVerkey } = messageContext;
        if (!recipientVerkey || !senderVerkey) {
            throw new error_1.AriesFrameworkError('Unable to process connection request without senderVerkey or recipientVerkey');
        }
        let connectionRecord = await this.findByVerkey(recipientVerkey);
        if (!connectionRecord) {
            throw new error_1.AriesFrameworkError(`Unable to process connection request: connection for verkey ${recipientVerkey} not found`);
        }
        connectionRecord.assertState(models_1.ConnectionState.Invited);
        connectionRecord.assertRole(models_1.ConnectionRole.Inviter);
        if (!message.connection.didDoc) {
            throw new errors_1.ConnectionProblemReportError('Public DIDs are not supported yet', {
                problemCode: errors_1.ConnectionProblemReportReason.RequestNotAccepted,
            });
        }
        // Create new connection if using a multi use invitation
        if (connectionRecord.multiUseInvitation) {
            if (!routing) {
                throw new error_1.AriesFrameworkError('Cannot process request for multi-use invitation without routing object. Make sure to call processRequest with the routing parameter provided.');
            }
            connectionRecord = await this.createConnection({
                role: connectionRecord.role,
                state: connectionRecord.state,
                multiUseInvitation: false,
                routing,
                autoAcceptConnection: connectionRecord.autoAcceptConnection,
                invitation: connectionRecord.invitation,
                tags: connectionRecord.getTags(),
            });
        }
        connectionRecord.theirDidDoc = message.connection.didDoc;
        connectionRecord.theirLabel = message.label;
        connectionRecord.threadId = message.id;
        connectionRecord.theirDid = message.connection.did;
        connectionRecord.imageUrl = message.imageUrl;
        if (!connectionRecord.theirKey) {
            throw new error_1.AriesFrameworkError(`Connection with id ${connectionRecord.id} has no recipient keys.`);
        }
        await this.updateState(connectionRecord, models_1.ConnectionState.Requested);
        return connectionRecord;
    }
    /**
     * Create a connection response message for the connection with the specified connection id.
     *
     * @param connectionId the id of the connection for which to create a connection response
     * @returns outbound message containing connection response
     */
    async createResponse(connectionId) {
        var _a;
        const connectionRecord = await this.connectionRepository.getById(connectionId);
        connectionRecord.assertState(models_1.ConnectionState.Requested);
        connectionRecord.assertRole(models_1.ConnectionRole.Inviter);
        const connection = new models_1.Connection({
            did: connectionRecord.did,
            didDoc: connectionRecord.didDoc,
        });
        const connectionJson = JsonTransformer_1.JsonTransformer.toJSON(connection);
        if (!connectionRecord.threadId) {
            throw new error_1.AriesFrameworkError(`Connection record with id ${connectionId} does not have a thread id`);
        }
        // Use invitationKey by default, fall back to verkey
        const signingKey = (_a = connectionRecord.getTag('invitationKey')) !== null && _a !== void 0 ? _a : connectionRecord.verkey;
        const connectionResponse = new messages_1.ConnectionResponseMessage({
            threadId: connectionRecord.threadId,
            connectionSig: await SignatureDecoratorUtils_1.signData(connectionJson, this.wallet, signingKey),
        });
        await this.updateState(connectionRecord, models_1.ConnectionState.Responded);
        return {
            connectionRecord: connectionRecord,
            message: connectionResponse,
        };
    }
    /**
     * Process a received connection response message. This will not accept the connection request
     * or send a connection acknowledgement message. It will only update the existing connection record
     * with all the new information from the connection response message. Use {@link ConnectionService.createTrustPing}
     * after calling this function to create a trust ping message.
     *
     * @param messageContext the message context containing a connection response message
     * @returns updated connection record
     */
    async processResponse(messageContext) {
        const { message, recipientVerkey, senderVerkey } = messageContext;
        if (!recipientVerkey || !senderVerkey) {
            throw new error_1.AriesFrameworkError('Unable to process connection request without senderVerkey or recipientVerkey');
        }
        const connectionRecord = await this.findByVerkey(recipientVerkey);
        if (!connectionRecord) {
            throw new error_1.AriesFrameworkError(`Unable to process connection response: connection for verkey ${recipientVerkey} not found`);
        }
        connectionRecord.assertState(models_1.ConnectionState.Requested);
        connectionRecord.assertRole(models_1.ConnectionRole.Invitee);
        let connectionJson = null;
        try {
            connectionJson = await SignatureDecoratorUtils_1.unpackAndVerifySignatureDecorator(message.connectionSig, this.wallet);
        }
        catch (error) {
            if (error instanceof error_1.AriesFrameworkError) {
                throw new errors_1.ConnectionProblemReportError(error.message, {
                    problemCode: errors_1.ConnectionProblemReportReason.RequestProcessingError,
                });
            }
        }
        const connection = JsonTransformer_1.JsonTransformer.fromJSON(connectionJson, models_1.Connection);
        await MessageValidator_1.MessageValidator.validate(connection);
        // Per the Connection RFC we must check if the key used to sign the connection~sig is the same key
        // as the recipient key(s) in the connection invitation message
        const signerVerkey = message.connectionSig.signer;
        const invitationKey = connectionRecord.getTags().invitationKey;
        if (signerVerkey !== invitationKey) {
            throw new errors_1.ConnectionProblemReportError(`Connection object in connection response message is not signed with same key as recipient key in invitation expected='${invitationKey}' received='${signerVerkey}'`, { problemCode: errors_1.ConnectionProblemReportReason.ResponseNotAccepted });
        }
        connectionRecord.theirDid = connection.did;
        connectionRecord.theirDidDoc = connection.didDoc;
        connectionRecord.threadId = message.threadId;
        if (!connectionRecord.theirKey) {
            throw new error_1.AriesFrameworkError(`Connection with id ${connectionRecord.id} has no recipient keys.`);
        }
        await this.updateState(connectionRecord, models_1.ConnectionState.Responded);
        return connectionRecord;
    }
    /**
     * Create a trust ping message for the connection with the specified connection id.
     *
     * By default a trust ping message should elicit a response. If this is not desired the
     * `config.responseRequested` property can be set to `false`.
     *
     * @param connectionId the id of the connection for which to create a trust ping message
     * @param config the config for the trust ping message
     * @returns outbound message containing trust ping message
     */
    async createTrustPing(connectionId, config = {}) {
        const connectionRecord = await this.connectionRepository.getById(connectionId);
        connectionRecord.assertState([models_1.ConnectionState.Responded, models_1.ConnectionState.Complete]);
        // TODO:
        //  - create ack message
        //  - maybe this shouldn't be in the connection service?
        const trustPing = new messages_1.TrustPingMessage(config);
        await this.updateState(connectionRecord, models_1.ConnectionState.Complete);
        return {
            connectionRecord: connectionRecord,
            message: trustPing,
        };
    }
    /**
     * Process a received ack message. This will update the state of the connection
     * to Completed if this is not already the case.
     *
     * @param messageContext the message context containing an ack message
     * @returns updated connection record
     */
    async processAck(messageContext) {
        const { connection, recipientVerkey } = messageContext;
        if (!connection) {
            throw new error_1.AriesFrameworkError(`Unable to process connection ack: connection for verkey ${recipientVerkey} not found`);
        }
        // TODO: This is better addressed in a middleware of some kind because
        // any message can transition the state to complete, not just an ack or trust ping
        if (connection.state === models_1.ConnectionState.Responded && connection.role === models_1.ConnectionRole.Inviter) {
            await this.updateState(connection, models_1.ConnectionState.Complete);
        }
        return connection;
    }
    /**
     * Process a received {@link ProblemReportMessage}.
     *
     * @param messageContext The message context containing a connection problem report message
     * @returns connection record associated with the connection problem report message
     *
     */
    async processProblemReport(messageContext) {
        const { message: connectionProblemReportMessage, recipientVerkey, senderVerkey } = messageContext;
        this.logger.debug(`Processing connection problem report for verkey ${recipientVerkey}`);
        if (!recipientVerkey) {
            throw new error_1.AriesFrameworkError('Unable to process connection problem report without recipientVerkey');
        }
        const connectionRecord = await this.findByVerkey(recipientVerkey);
        if (!connectionRecord) {
            throw new error_1.AriesFrameworkError(`Unable to process connection problem report: connection for verkey ${recipientVerkey} not found`);
        }
        if (connectionRecord.theirKey && connectionRecord.theirKey !== senderVerkey) {
            throw new error_1.AriesFrameworkError("Sender verkey doesn't match verkey of connection record");
        }
        connectionRecord.errorMessage = `${connectionProblemReportMessage.description.code} : ${connectionProblemReportMessage.description.en}`;
        await this.update(connectionRecord);
        return connectionRecord;
    }
    /**
     * Assert that an inbound message either has a connection associated with it,
     * or has everything correctly set up for connection-less exchange.
     *
     * @param messageContext - the inbound message context
     * @param previousRespondence - previous sent and received message to determine if a valid service decorator is present
     */
    assertConnectionOrServiceDecorator(messageContext, { previousSentMessage, previousReceivedMessage, } = {}) {
        const { connection, message } = messageContext;
        // Check if we have a ready connection. Verification is already done somewhere else. Return
        if (connection) {
            connection.assertReady();
            this.logger.debug(`Processing message with id ${message.id} and connection id ${connection.id}`, {
                type: message.type,
            });
        }
        else {
            this.logger.debug(`Processing connection-less message with id ${message.id}`, {
                type: message.type,
            });
            if (previousSentMessage) {
                // If we have previously sent a message, it is not allowed to receive an OOB/unpacked message
                if (!messageContext.recipientVerkey) {
                    throw new error_1.AriesFrameworkError('Cannot verify service without recipientKey on incoming message (received unpacked message)');
                }
                // Check if the inbound message recipient key is present
                // in the recipientKeys of previously sent message ~service decorator
                if (!(previousSentMessage === null || previousSentMessage === void 0 ? void 0 : previousSentMessage.service) ||
                    !previousSentMessage.service.recipientKeys.includes(messageContext.recipientVerkey)) {
                    throw new error_1.AriesFrameworkError('Previously sent message ~service recipientKeys does not include current received message recipient key');
                }
            }
            if (previousReceivedMessage) {
                // If we have previously received a message, it is not allowed to receive an OOB/unpacked/AnonCrypt message
                if (!messageContext.senderVerkey) {
                    throw new error_1.AriesFrameworkError('Cannot verify service without senderKey on incoming message (received AnonCrypt or unpacked message)');
                }
                // Check if the inbound message sender key is present
                // in the recipientKeys of previously received message ~service decorator
                if (!previousReceivedMessage.service ||
                    !previousReceivedMessage.service.recipientKeys.includes(messageContext.senderVerkey)) {
                    throw new error_1.AriesFrameworkError('Previously received message ~service recipientKeys does not include current received message sender key');
                }
            }
            // If message is received unpacked/, we need to make sure it included a ~service decorator
            if (!message.service && !messageContext.recipientVerkey) {
                throw new error_1.AriesFrameworkError('Message recipientKey must have ~service decorator');
            }
        }
    }
    async updateState(connectionRecord, newState) {
        const previousState = connectionRecord.state;
        connectionRecord.state = newState;
        await this.connectionRepository.update(connectionRecord);
        this.eventEmitter.emit({
            type: ConnectionEvents_1.ConnectionEventTypes.ConnectionStateChanged,
            payload: {
                connectionRecord: connectionRecord,
                previousState,
            },
        });
    }
    update(connectionRecord) {
        return this.connectionRepository.update(connectionRecord);
    }
    /**
     * Retrieve all connections records
     *
     * @returns List containing all connection records
     */
    getAll() {
        return this.connectionRepository.getAll();
    }
    /**
     * Retrieve a connection record by id
     *
     * @param connectionId The connection record id
     * @throws {RecordNotFoundError} If no record is found
     * @return The connection record
     *
     */
    getById(connectionId) {
        return this.connectionRepository.getById(connectionId);
    }
    /**
     * Find a connection record by id
     *
     * @param connectionId the connection record id
     * @returns The connection record or null if not found
     */
    findById(connectionId) {
        return this.connectionRepository.findById(connectionId);
    }
    /**
     * Delete a connection record by id
     *
     * @param connectionId the connection record id
     */
    async deleteById(connectionId) {
        const connectionRecord = await this.getById(connectionId);
        return this.connectionRepository.delete(connectionRecord);
    }
    /**
     * Find connection by verkey.
     *
     * @param verkey the verkey to search for
     * @returns the connection record, or null if not found
     * @throws {RecordDuplicateError} if multiple connections are found for the given verkey
     */
    findByVerkey(verkey) {
        return this.connectionRepository.findSingleByQuery({
            verkey,
        });
    }
    /**
     * Find connection by their verkey.
     *
     * @param verkey the verkey to search for
     * @returns the connection record, or null if not found
     * @throws {RecordDuplicateError} if multiple connections are found for the given verkey
     */
    findByTheirKey(verkey) {
        return this.connectionRepository.findSingleByQuery({
            theirKey: verkey,
        });
    }
    /**
     * Find connection by invitation key.
     *
     * @param key the invitation key to search for
     * @returns the connection record, or null if not found
     * @throws {RecordDuplicateError} if multiple connections are found for the given verkey
     */
    findByInvitationKey(key) {
        return this.connectionRepository.findSingleByQuery({
            invitationKey: key,
        });
    }
    /**
     * Retrieve a connection record by thread id
     *
     * @param threadId The thread id
     * @throws {RecordNotFoundError} If no record is found
     * @throws {RecordDuplicateError} If multiple records are found
     * @returns The connection record
     */
    getByThreadId(threadId) {
        return this.connectionRepository.getSingleByQuery({ threadId });
    }
    async createConnection(options) {
        const { endpoints, did, verkey, routingKeys, mediatorId } = options.routing;
        const publicKey = new models_1.Ed25119Sig2018({
            id: `${did}#1`,
            controller: did,
            publicKeyBase58: verkey,
        });
        // IndyAgentService is old service type
        const services = endpoints.map((endpoint, index) => new models_1.IndyAgentService({
            id: `${did}#IndyAgentService`,
            serviceEndpoint: endpoint,
            recipientKeys: [verkey],
            routingKeys: routingKeys,
            // Order of endpoint determines priority
            priority: index,
        }));
        // TODO: abstract the second parameter for ReferencedAuthentication away. This can be
        // inferred from the publicKey class instance
        const auth = new models_1.ReferencedAuthentication(publicKey, models_1.authenticationTypes[publicKey.type]);
        const didDoc = new models_1.DidDoc({
            id: did,
            authentication: [auth],
            service: services,
            publicKey: [publicKey],
        });
        const connectionRecord = new ConnectionRecord_1.ConnectionRecord({
            did,
            didDoc,
            verkey,
            state: options.state,
            role: options.role,
            tags: options.tags,
            invitation: options.invitation,
            alias: options.alias,
            theirLabel: options.theirLabel,
            autoAcceptConnection: options.autoAcceptConnection,
            imageUrl: options.imageUrl,
            multiUseInvitation: options.multiUseInvitation,
            mediatorId,
        });
        await this.connectionRepository.save(connectionRecord);
        return connectionRecord;
    }
    async returnWhenIsConnected(connectionId, timeoutMs = 20000) {
        const isConnected = (connection) => {
            return connection.id === connectionId && connection.state === models_1.ConnectionState.Complete;
        };
        const observable = this.eventEmitter.observable(ConnectionEvents_1.ConnectionEventTypes.ConnectionStateChanged);
        const subject = new rxjs_1.ReplaySubject(1);
        observable
            .pipe(operators_1.map((e) => e.payload.connectionRecord), operators_1.first(isConnected), // Do not wait for longer than specified timeout
        operators_1.timeout(timeoutMs))
            .subscribe(subject);
        const connection = await this.getById(connectionId);
        if (isConnected(connection)) {
            subject.next(connection);
        }
        return rxjs_1.firstValueFrom(subject);
    }
};
ConnectionService = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __param(0, tsyringe_1.inject(constants_1.InjectionSymbols.Wallet)),
    __metadata("design:paramtypes", [Object, AgentConfig_1.AgentConfig,
        ConnectionRepository_1.ConnectionRepository,
        EventEmitter_1.EventEmitter])
], ConnectionService);
exports.ConnectionService = ConnectionService;
//# sourceMappingURL=ConnectionService.js.map
import type * as Indy from 'indy-sdk';
import { AgentConfig } from '../../../agent/AgentConfig';
import { CacheRepository } from '../../../cache';
import { IndyPool } from '../IndyPool';
export declare const DID_POOL_CACHE_ID = "DID_POOL_CACHE";
export declare const DID_POOL_CACHE_LIMIT = 500;
export interface CachedDidResponse {
    nymResponse: Indy.GetNymResponse;
    poolId: string;
}
export declare class IndyPoolService {
    readonly pools: IndyPool[];
    private logger;
    private indy;
    private didCache;
    constructor(agentConfig: AgentConfig, cacheRepository: CacheRepository);
    /**
     * Get the pool used for writing to the ledger. For now we always use the first pool
     *  as the pool that writes to the ledger
     */
    get ledgerWritePool(): IndyPool;
    /**
     * Get the most appropriate pool for the given did. The algorithm is based on the approach as described in this document:
     * https://docs.google.com/document/d/109C_eMsuZnTnYe2OAd02jAts1vC4axwEKIq7_4dnNVA/edit
     */
    getPoolForDid(did: string): Promise<{
        pool: IndyPool;
        did: Indy.GetNymResponse;
    }>;
    private getSettledDidResponsesFromPools;
    private getDidFromPool;
}
export interface PublicDidRequest {
    did: Indy.GetNymResponse;
    pool: IndyPool;
    response: Indy.LedgerReadReplyResponse;
}

"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialsModule = void 0;
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../agent/AgentConfig");
const Dispatcher_1 = require("../../agent/Dispatcher");
const MessageSender_1 = require("../../agent/MessageSender");
const helpers_1 = require("../../agent/helpers");
const ServiceDecorator_1 = require("../../decorators/service/ServiceDecorator");
const error_1 = require("../../error");
const attachment_1 = require("../../utils/attachment");
const ConnectionService_1 = require("../connections/services/ConnectionService");
const routing_1 = require("../routing");
const CredentialResponseCoordinator_1 = require("./CredentialResponseCoordinator");
const errors_1 = require("./errors");
const handlers_1 = require("./handlers");
const messages_1 = require("./messages");
const services_1 = require("./services");
let CredentialsModule = class CredentialsModule {
    constructor(dispatcher, connectionService, credentialService, messageSender, agentConfig, credentialResponseCoordinator, mediationRecipientService) {
        this.connectionService = connectionService;
        this.credentialService = credentialService;
        this.messageSender = messageSender;
        this.agentConfig = agentConfig;
        this.credentialResponseCoordinator = credentialResponseCoordinator;
        this.mediationRecipientService = mediationRecipientService;
        this.registerHandlers(dispatcher);
    }
    /**
     * Initiate a new credential exchange as holder by sending a credential proposal message
     * to the connection with the specified connection id.
     *
     * @param connectionId The connection to send the credential proposal to
     * @param config Additional configuration to use for the proposal
     * @returns Credential record associated with the sent proposal message
     */
    async proposeCredential(connectionId, config) {
        const connection = await this.connectionService.getById(connectionId);
        const { message, credentialRecord } = await this.credentialService.createProposal(connection, config);
        const outbound = helpers_1.createOutboundMessage(connection, message);
        await this.messageSender.sendMessage(outbound);
        return credentialRecord;
    }
    /**
     * Accept a credential proposal as issuer (by sending a credential offer message) to the connection
     * associated with the credential record.
     *
     * @param credentialRecordId The id of the credential record for which to accept the proposal
     * @param config Additional configuration to use for the offer
     * @returns Credential record associated with the credential offer
     *
     */
    async acceptProposal(credentialRecordId, config) {
        var _a, _b;
        const credentialRecord = await this.credentialService.getById(credentialRecordId);
        if (!credentialRecord.connectionId) {
            throw new error_1.AriesFrameworkError(`No connectionId found for credential record '${credentialRecord.id}'. Connection-less issuance does not support credential proposal or negotiation.`);
        }
        const connection = await this.connectionService.getById(credentialRecord.connectionId);
        const credentialProposalMessage = credentialRecord.proposalMessage;
        if (!(credentialProposalMessage === null || credentialProposalMessage === void 0 ? void 0 : credentialProposalMessage.credentialProposal)) {
            throw new error_1.AriesFrameworkError(`Credential record with id ${credentialRecordId} is missing required credential proposal`);
        }
        const credentialDefinitionId = (_a = config === null || config === void 0 ? void 0 : config.credentialDefinitionId) !== null && _a !== void 0 ? _a : credentialProposalMessage.credentialDefinitionId;
        credentialRecord.linkedAttachments = (_b = credentialProposalMessage.attachments) === null || _b === void 0 ? void 0 : _b.filter((attachment) => attachment_1.isLinkedAttachment(attachment));
        if (!credentialDefinitionId) {
            throw new error_1.AriesFrameworkError('Missing required credential definition id. If credential proposal message contains no credential definition id it must be passed to config.');
        }
        // TODO: check if it is possible to issue credential based on proposal filters
        const { message } = await this.credentialService.createOfferAsResponse(credentialRecord, {
            preview: credentialProposalMessage.credentialProposal,
            credentialDefinitionId,
            comment: config === null || config === void 0 ? void 0 : config.comment,
            autoAcceptCredential: config === null || config === void 0 ? void 0 : config.autoAcceptCredential,
            attachments: credentialRecord.linkedAttachments,
        });
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.messageSender.sendMessage(outboundMessage);
        return credentialRecord;
    }
    /**
     * Negotiate a credential proposal as issuer (by sending a credential offer message) to the connection
     * associated with the credential record.
     *
     * @param credentialRecordId The id of the credential record for which to accept the proposal
     * @param preview The new preview for negotiation
     * @param config Additional configuration to use for the offer
     * @returns Credential record associated with the credential offer
     *
     */
    async negotiateProposal(credentialRecordId, preview, config) {
        var _a;
        const credentialRecord = await this.credentialService.getById(credentialRecordId);
        if (!credentialRecord.connectionId) {
            throw new error_1.AriesFrameworkError(`No connectionId found for credential record '${credentialRecord.id}'. Connection-less issuance does not support negotiation.`);
        }
        const connection = await this.connectionService.getById(credentialRecord.connectionId);
        const credentialProposalMessage = credentialRecord.proposalMessage;
        if (!(credentialProposalMessage === null || credentialProposalMessage === void 0 ? void 0 : credentialProposalMessage.credentialProposal)) {
            throw new error_1.AriesFrameworkError(`Credential record with id ${credentialRecordId} is missing required credential proposal`);
        }
        const credentialDefinitionId = (_a = config === null || config === void 0 ? void 0 : config.credentialDefinitionId) !== null && _a !== void 0 ? _a : credentialProposalMessage.credentialDefinitionId;
        if (!credentialDefinitionId) {
            throw new error_1.AriesFrameworkError('Missing required credential definition id. If credential proposal message contains no credential definition id it must be passed to config.');
        }
        const { message } = await this.credentialService.createOfferAsResponse(credentialRecord, {
            preview,
            credentialDefinitionId,
            comment: config === null || config === void 0 ? void 0 : config.comment,
            autoAcceptCredential: config === null || config === void 0 ? void 0 : config.autoAcceptCredential,
            attachments: credentialRecord.linkedAttachments,
        });
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.messageSender.sendMessage(outboundMessage);
        return credentialRecord;
    }
    /**
     * Initiate a new credential exchange as issuer by sending a credential offer message
     * to the connection with the specified connection id.
     *
     * @param connectionId The connection to send the credential offer to
     * @param credentialTemplate The credential template to use for the offer
     * @returns Credential record associated with the sent credential offer message
     */
    async offerCredential(connectionId, credentialTemplate) {
        const connection = await this.connectionService.getById(connectionId);
        const { message, credentialRecord } = await this.credentialService.createOffer(credentialTemplate, connection);
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.messageSender.sendMessage(outboundMessage);
        return credentialRecord;
    }
    /**
     * Initiate a new credential exchange as issuer by creating a credential offer
     * not bound to any connection. The offer must be delivered out-of-band to the holder
     *
     * @param credentialTemplate The credential template to use for the offer
     * @returns The credential record and credential offer message
     */
    async createOutOfBandOffer(credentialTemplate) {
        const { message, credentialRecord } = await this.credentialService.createOffer(credentialTemplate);
        // Create and set ~service decorator
        const routing = await this.mediationRecipientService.getRouting();
        message.service = new ServiceDecorator_1.ServiceDecorator({
            serviceEndpoint: routing.endpoints[0],
            recipientKeys: [routing.verkey],
            routingKeys: routing.routingKeys,
        });
        // Save ~service decorator to record (to remember our verkey)
        credentialRecord.offerMessage = message;
        await this.credentialService.update(credentialRecord);
        return { credentialRecord, offerMessage: message };
    }
    /**
     * Accept a credential offer as holder (by sending a credential request message) to the connection
     * associated with the credential record.
     *
     * @param credentialRecordId The id of the credential record for which to accept the offer
     * @param config Additional configuration to use for the request
     * @returns Credential record associated with the sent credential request message
     *
     */
    async acceptOffer(credentialRecordId, config) {
        var _a;
        const record = await this.credentialService.getById(credentialRecordId);
        // Use connection if present
        if (record.connectionId) {
            const connection = await this.connectionService.getById(record.connectionId);
            const { message, credentialRecord } = await this.credentialService.createRequest(record, Object.assign(Object.assign({}, config), { holderDid: connection.did }));
            const outboundMessage = helpers_1.createOutboundMessage(connection, message);
            await this.messageSender.sendMessage(outboundMessage);
            return credentialRecord;
        }
        // Use ~service decorator otherwise
        else if ((_a = record.offerMessage) === null || _a === void 0 ? void 0 : _a.service) {
            // Create ~service decorator
            const routing = await this.mediationRecipientService.getRouting();
            const ourService = new ServiceDecorator_1.ServiceDecorator({
                serviceEndpoint: routing.endpoints[0],
                recipientKeys: [routing.verkey],
                routingKeys: routing.routingKeys,
            });
            const recipientService = record.offerMessage.service;
            const { message, credentialRecord } = await this.credentialService.createRequest(record, Object.assign(Object.assign({}, config), { holderDid: ourService.recipientKeys[0] }));
            // Set and save ~service decorator to record (to remember our verkey)
            message.service = ourService;
            credentialRecord.requestMessage = message;
            await this.credentialService.update(credentialRecord);
            await this.messageSender.sendMessageToService({
                message,
                service: recipientService.toDidCommService(),
                senderKey: ourService.recipientKeys[0],
                returnRoute: true,
            });
            return credentialRecord;
        }
        // Cannot send message without connectionId or ~service decorator
        else {
            throw new error_1.AriesFrameworkError(`Cannot accept offer for credential record without connectionId or ~service decorator on credential offer.`);
        }
    }
    /**
     * Declines an offer as holder
     * @param credentialRecordId the id of the credential to be declined
     * @returns credential record that was declined
     */
    async declineOffer(credentialRecordId) {
        const credentialRecord = await this.credentialService.getById(credentialRecordId);
        await this.credentialService.declineOffer(credentialRecord);
        return credentialRecord;
    }
    /**
     * Negotiate a credential offer as holder (by sending a credential proposal message) to the connection
     * associated with the credential record.
     *
     * @param credentialRecordId The id of the credential record for which to accept the offer
     * @param preview The new preview for negotiation
     * @param config Additional configuration to use for the request
     * @returns Credential record associated with the sent credential request message
     *
     */
    async negotiateOffer(credentialRecordId, preview, config) {
        const credentialRecord = await this.credentialService.getById(credentialRecordId);
        if (!credentialRecord.connectionId) {
            throw new error_1.AriesFrameworkError(`No connectionId found for credential record '${credentialRecord.id}'. Connection-less issuance does not support negotiation.`);
        }
        const connection = await this.connectionService.getById(credentialRecord.connectionId);
        const { message } = await this.credentialService.createProposalAsResponse(credentialRecord, Object.assign(Object.assign({}, config), { credentialProposal: preview }));
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.messageSender.sendMessage(outboundMessage);
        return credentialRecord;
    }
    /**
     * Accept a credential request as issuer (by sending a credential message) to the connection
     * associated with the credential record.
     *
     * @param credentialRecordId The id of the credential record for which to accept the request
     * @param config Additional configuration to use for the credential
     * @returns Credential record associated with the sent presentation message
     *
     */
    async acceptRequest(credentialRecordId, config) {
        var _a, _b;
        const record = await this.credentialService.getById(credentialRecordId);
        const { message, credentialRecord } = await this.credentialService.createCredential(record, config);
        // Use connection if present
        if (credentialRecord.connectionId) {
            const connection = await this.connectionService.getById(credentialRecord.connectionId);
            const outboundMessage = helpers_1.createOutboundMessage(connection, message);
            await this.messageSender.sendMessage(outboundMessage);
        }
        // Use ~service decorator otherwise
        else if (((_a = credentialRecord.requestMessage) === null || _a === void 0 ? void 0 : _a.service) && ((_b = credentialRecord.offerMessage) === null || _b === void 0 ? void 0 : _b.service)) {
            const recipientService = credentialRecord.requestMessage.service;
            const ourService = credentialRecord.offerMessage.service;
            // Set ~service, update message in record (for later use)
            message.setService(ourService);
            credentialRecord.credentialMessage = message;
            await this.credentialService.update(credentialRecord);
            await this.messageSender.sendMessageToService({
                message,
                service: recipientService.toDidCommService(),
                senderKey: ourService.recipientKeys[0],
                returnRoute: true,
            });
        }
        // Cannot send message without connectionId or ~service decorator
        else {
            throw new error_1.AriesFrameworkError(`Cannot accept request for credential record without connectionId or ~service decorator on credential offer / request.`);
        }
        return credentialRecord;
    }
    /**
     * Accept a credential as holder (by sending a credential acknowledgement message) to the connection
     * associated with the credential record.
     *
     * @param credentialRecordId The id of the credential record for which to accept the credential
     * @returns credential record associated with the sent credential acknowledgement message
     *
     */
    async acceptCredential(credentialRecordId) {
        var _a, _b;
        const record = await this.credentialService.getById(credentialRecordId);
        const { message, credentialRecord } = await this.credentialService.createAck(record);
        if (credentialRecord.connectionId) {
            const connection = await this.connectionService.getById(credentialRecord.connectionId);
            const outboundMessage = helpers_1.createOutboundMessage(connection, message);
            await this.messageSender.sendMessage(outboundMessage);
        }
        // Use ~service decorator otherwise
        else if (((_a = credentialRecord.credentialMessage) === null || _a === void 0 ? void 0 : _a.service) && ((_b = credentialRecord.requestMessage) === null || _b === void 0 ? void 0 : _b.service)) {
            const recipientService = credentialRecord.credentialMessage.service;
            const ourService = credentialRecord.requestMessage.service;
            await this.messageSender.sendMessageToService({
                message,
                service: recipientService.toDidCommService(),
                senderKey: ourService.recipientKeys[0],
                returnRoute: true,
            });
        }
        // Cannot send message without connectionId or ~service decorator
        else {
            throw new error_1.AriesFrameworkError(`Cannot accept credential without connectionId or ~service decorator on credential message.`);
        }
        return credentialRecord;
    }
    /**
     * Send problem report message for a credential record
     * @param credentialRecordId  The id of the credential record for which to send problem report
     * @param message message to send
     * @returns credential record associated with credential problem report message
     */
    async sendProblemReport(credentialRecordId, message) {
        const record = await this.credentialService.getById(credentialRecordId);
        if (!record.connectionId) {
            throw new error_1.AriesFrameworkError(`No connectionId found for credential record '${record.id}'.`);
        }
        const connection = await this.connectionService.getById(record.connectionId);
        const credentialProblemReportMessage = new messages_1.CredentialProblemReportMessage({
            description: {
                en: message,
                code: errors_1.CredentialProblemReportReason.IssuanceAbandoned,
            },
        });
        credentialProblemReportMessage.setThread({
            threadId: record.threadId,
        });
        const outboundMessage = helpers_1.createOutboundMessage(connection, credentialProblemReportMessage);
        await this.messageSender.sendMessage(outboundMessage);
        return record;
    }
    /**
     * Retrieve all credential records
     *
     * @returns List containing all credential records
     */
    getAll() {
        return this.credentialService.getAll();
    }
    /**
     * Retrieve a credential record by id
     *
     * @param credentialRecordId The credential record id
     * @throws {RecordNotFoundError} If no record is found
     * @return The credential record
     *
     */
    getById(credentialRecordId) {
        return this.credentialService.getById(credentialRecordId);
    }
    /**
     * Find a credential record by id
     *
     * @param credentialRecordId the credential record id
     * @returns The credential record or null if not found
     */
    findById(connectionId) {
        return this.credentialService.findById(connectionId);
    }
    /**
     * Delete a credential record by id
     *
     * @param credentialId the credential record id
     */
    async deleteById(credentialId) {
        return this.credentialService.deleteById(credentialId);
    }
    registerHandlers(dispatcher) {
        dispatcher.registerHandler(new handlers_1.ProposeCredentialHandler(this.credentialService, this.agentConfig, this.credentialResponseCoordinator));
        dispatcher.registerHandler(new handlers_1.OfferCredentialHandler(this.credentialService, this.agentConfig, this.credentialResponseCoordinator, this.mediationRecipientService));
        dispatcher.registerHandler(new handlers_1.RequestCredentialHandler(this.credentialService, this.agentConfig, this.credentialResponseCoordinator));
        dispatcher.registerHandler(new handlers_1.IssueCredentialHandler(this.credentialService, this.agentConfig, this.credentialResponseCoordinator));
        dispatcher.registerHandler(new handlers_1.CredentialAckHandler(this.credentialService));
        dispatcher.registerHandler(new handlers_1.CredentialProblemReportHandler(this.credentialService));
    }
};
CredentialsModule = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __metadata("design:paramtypes", [Dispatcher_1.Dispatcher,
        ConnectionService_1.ConnectionService,
        services_1.CredentialService,
        MessageSender_1.MessageSender,
        AgentConfig_1.AgentConfig,
        CredentialResponseCoordinator_1.CredentialResponseCoordinator,
        routing_1.MediationRecipientService])
], CredentialsModule);
exports.CredentialsModule = CredentialsModule;
//# sourceMappingURL=CredentialsModule.js.map
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProofsModule = void 0;
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../agent/AgentConfig");
const Dispatcher_1 = require("../../agent/Dispatcher");
const MessageSender_1 = require("../../agent/MessageSender");
const helpers_1 = require("../../agent/helpers");
const ServiceDecorator_1 = require("../../decorators/service/ServiceDecorator");
const error_1 = require("../../error");
const ConnectionService_1 = require("../connections/services/ConnectionService");
const MediationRecipientService_1 = require("../routing/services/MediationRecipientService");
const ProofResponseCoordinator_1 = require("./ProofResponseCoordinator");
const errors_1 = require("./errors");
const handlers_1 = require("./handlers");
const PresentationProblemReportMessage_1 = require("./messages/PresentationProblemReportMessage");
const ProofRequest_1 = require("./models/ProofRequest");
const services_1 = require("./services");
let ProofsModule = class ProofsModule {
    constructor(dispatcher, proofService, connectionService, mediationRecipientService, agentConfig, messageSender, proofResponseCoordinator) {
        this.proofService = proofService;
        this.connectionService = connectionService;
        this.messageSender = messageSender;
        this.mediationRecipientService = mediationRecipientService;
        this.agentConfig = agentConfig;
        this.proofResponseCoordinator = proofResponseCoordinator;
        this.registerHandlers(dispatcher);
    }
    /**
     * Initiate a new presentation exchange as prover by sending a presentation proposal message
     * to the connection with the specified connection id.
     *
     * @param connectionId The connection to send the proof proposal to
     * @param presentationProposal The presentation proposal to include in the message
     * @param config Additional configuration to use for the proposal
     * @returns Proof record associated with the sent proposal message
     *
     */
    async proposeProof(connectionId, presentationProposal, config) {
        const connection = await this.connectionService.getById(connectionId);
        const { message, proofRecord } = await this.proofService.createProposal(connection, presentationProposal, config);
        const outbound = helpers_1.createOutboundMessage(connection, message);
        await this.messageSender.sendMessage(outbound);
        return proofRecord;
    }
    /**
     * Accept a presentation proposal as verifier (by sending a presentation request message) to the connection
     * associated with the proof record.
     *
     * @param proofRecordId The id of the proof record for which to accept the proposal
     * @param config Additional configuration to use for the request
     * @returns Proof record associated with the presentation request
     *
     */
    async acceptProposal(proofRecordId, config) {
        var _a, _b, _c, _d, _e, _f;
        const proofRecord = await this.proofService.getById(proofRecordId);
        if (!proofRecord.connectionId) {
            throw new error_1.AriesFrameworkError(`No connectionId found for credential record '${proofRecord.id}'. Connection-less issuance does not support presentation proposal or negotiation.`);
        }
        const connection = await this.connectionService.getById(proofRecord.connectionId);
        const presentationProposal = (_a = proofRecord.proposalMessage) === null || _a === void 0 ? void 0 : _a.presentationProposal;
        if (!presentationProposal) {
            throw new error_1.AriesFrameworkError(`Proof record with id ${proofRecordId} is missing required presentation proposal`);
        }
        const proofRequest = await this.proofService.createProofRequestFromProposal(presentationProposal, {
            name: (_c = (_b = config === null || config === void 0 ? void 0 : config.request) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : 'proof-request',
            version: (_e = (_d = config === null || config === void 0 ? void 0 : config.request) === null || _d === void 0 ? void 0 : _d.version) !== null && _e !== void 0 ? _e : '1.0',
            nonce: (_f = config === null || config === void 0 ? void 0 : config.request) === null || _f === void 0 ? void 0 : _f.nonce,
        });
        const { message } = await this.proofService.createRequestAsResponse(proofRecord, proofRequest, {
            comment: config === null || config === void 0 ? void 0 : config.comment,
        });
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.messageSender.sendMessage(outboundMessage);
        return proofRecord;
    }
    /**
     * Initiate a new presentation exchange as verifier by sending a presentation request message
     * to the connection with the specified connection id
     *
     * @param connectionId The connection to send the proof request to
     * @param proofRequestOptions Options to build the proof request
     * @returns Proof record associated with the sent request message
     *
     */
    async requestProof(connectionId, proofRequestOptions, config) {
        var _a, _b, _c;
        const connection = await this.connectionService.getById(connectionId);
        const nonce = (_a = proofRequestOptions.nonce) !== null && _a !== void 0 ? _a : (await this.proofService.generateProofRequestNonce());
        const proofRequest = new ProofRequest_1.ProofRequest({
            name: (_b = proofRequestOptions.name) !== null && _b !== void 0 ? _b : 'proof-request',
            version: (_c = proofRequestOptions.name) !== null && _c !== void 0 ? _c : '1.0',
            nonce,
            requestedAttributes: proofRequestOptions.requestedAttributes,
            requestedPredicates: proofRequestOptions.requestedPredicates,
        });
        const { message, proofRecord } = await this.proofService.createRequest(proofRequest, connection, config);
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.messageSender.sendMessage(outboundMessage);
        return proofRecord;
    }
    /**
     * Initiate a new presentation exchange as verifier by creating a presentation request
     * not bound to any connection. The request must be delivered out-of-band to the holder
     *
     * @param proofRequestOptions Options to build the proof request
     * @returns The proof record and proof request message
     *
     */
    async createOutOfBandRequest(proofRequestOptions, config) {
        var _a, _b, _c;
        const nonce = (_a = proofRequestOptions.nonce) !== null && _a !== void 0 ? _a : (await this.proofService.generateProofRequestNonce());
        const proofRequest = new ProofRequest_1.ProofRequest({
            name: (_b = proofRequestOptions.name) !== null && _b !== void 0 ? _b : 'proof-request',
            version: (_c = proofRequestOptions.name) !== null && _c !== void 0 ? _c : '1.0',
            nonce,
            requestedAttributes: proofRequestOptions.requestedAttributes,
            requestedPredicates: proofRequestOptions.requestedPredicates,
        });
        const { message, proofRecord } = await this.proofService.createRequest(proofRequest, undefined, config);
        // Create and set ~service decorator
        const routing = await this.mediationRecipientService.getRouting();
        message.service = new ServiceDecorator_1.ServiceDecorator({
            serviceEndpoint: routing.endpoints[0],
            recipientKeys: [routing.verkey],
            routingKeys: routing.routingKeys,
        });
        // Save ~service decorator to record (to remember our verkey)
        proofRecord.requestMessage = message;
        await this.proofService.update(proofRecord);
        return { proofRecord, requestMessage: message };
    }
    /**
     * Accept a presentation request as prover (by sending a presentation message) to the connection
     * associated with the proof record.
     *
     * @param proofRecordId The id of the proof record for which to accept the request
     * @param requestedCredentials The requested credentials object specifying which credentials to use for the proof
     * @param config Additional configuration to use for the presentation
     * @returns Proof record associated with the sent presentation message
     *
     */
    async acceptRequest(proofRecordId, requestedCredentials, config) {
        var _a;
        const record = await this.proofService.getById(proofRecordId);
        const { message, proofRecord } = await this.proofService.createPresentation(record, requestedCredentials, config);
        // Use connection if present
        if (proofRecord.connectionId) {
            const connection = await this.connectionService.getById(proofRecord.connectionId);
            const outboundMessage = helpers_1.createOutboundMessage(connection, message);
            await this.messageSender.sendMessage(outboundMessage);
            return proofRecord;
        }
        // Use ~service decorator otherwise
        else if ((_a = proofRecord.requestMessage) === null || _a === void 0 ? void 0 : _a.service) {
            // Create ~service decorator
            const routing = await this.mediationRecipientService.getRouting();
            const ourService = new ServiceDecorator_1.ServiceDecorator({
                serviceEndpoint: routing.endpoints[0],
                recipientKeys: [routing.verkey],
                routingKeys: routing.routingKeys,
            });
            const recipientService = proofRecord.requestMessage.service;
            // Set and save ~service decorator to record (to remember our verkey)
            message.service = ourService;
            proofRecord.presentationMessage = message;
            await this.proofService.update(proofRecord);
            await this.messageSender.sendMessageToService({
                message,
                service: recipientService.toDidCommService(),
                senderKey: ourService.recipientKeys[0],
                returnRoute: true,
            });
            return proofRecord;
        }
        // Cannot send message without connectionId or ~service decorator
        else {
            throw new error_1.AriesFrameworkError(`Cannot accept presentation request without connectionId or ~service decorator on presentation request.`);
        }
    }
    /**
     * Declines a proof request as holder
     * @param proofRecordId the id of the proof request to be declined
     * @returns proof record that was declined
     */
    async declineRequest(proofRecordId) {
        const proofRecord = await this.proofService.getById(proofRecordId);
        await this.proofService.declineRequest(proofRecord);
        return proofRecord;
    }
    /**
     * Accept a presentation as prover (by sending a presentation acknowledgement message) to the connection
     * associated with the proof record.
     *
     * @param proofRecordId The id of the proof record for which to accept the presentation
     * @returns Proof record associated with the sent presentation acknowledgement message
     *
     */
    async acceptPresentation(proofRecordId) {
        var _a, _b, _c, _d;
        const record = await this.proofService.getById(proofRecordId);
        const { message, proofRecord } = await this.proofService.createAck(record);
        // Use connection if present
        if (proofRecord.connectionId) {
            const connection = await this.connectionService.getById(proofRecord.connectionId);
            const outboundMessage = helpers_1.createOutboundMessage(connection, message);
            await this.messageSender.sendMessage(outboundMessage);
        }
        // Use ~service decorator otherwise
        else if (((_a = proofRecord.requestMessage) === null || _a === void 0 ? void 0 : _a.service) && ((_b = proofRecord.presentationMessage) === null || _b === void 0 ? void 0 : _b.service)) {
            const recipientService = (_c = proofRecord.presentationMessage) === null || _c === void 0 ? void 0 : _c.service;
            const ourService = (_d = proofRecord.requestMessage) === null || _d === void 0 ? void 0 : _d.service;
            await this.messageSender.sendMessageToService({
                message,
                service: recipientService.toDidCommService(),
                senderKey: ourService.recipientKeys[0],
                returnRoute: true,
            });
        }
        // Cannot send message without credentialId or ~service decorator
        else {
            throw new error_1.AriesFrameworkError(`Cannot accept presentation without connectionId or ~service decorator on presentation message.`);
        }
        return proofRecord;
    }
    /**
     * Create a {@link RetrievedCredentials} object. Given input proof request and presentation proposal,
     * use credentials in the wallet to build indy requested credentials object for input to proof creation.
     * If restrictions allow, self attested attributes will be used.
     *
     *
     * @param proofRecordId the id of the proof request to get the matching credentials for
     * @param config optional configuration for credential selection process. Use `filterByPresentationPreview` (default `true`) to only include
     *  credentials that match the presentation preview from the presentation proposal (if available).
  
     * @returns RetrievedCredentials object
     */
    async getRequestedCredentialsForProofRequest(proofRecordId, config) {
        var _a, _b;
        const proofRecord = await this.proofService.getById(proofRecordId);
        const indyProofRequest = (_a = proofRecord.requestMessage) === null || _a === void 0 ? void 0 : _a.indyProofRequest;
        const presentationPreview = (config === null || config === void 0 ? void 0 : config.filterByPresentationPreview)
            ? (_b = proofRecord.proposalMessage) === null || _b === void 0 ? void 0 : _b.presentationProposal
            : undefined;
        if (!indyProofRequest) {
            throw new error_1.AriesFrameworkError('Unable to get requested credentials for proof request. No proof request message was found or the proof request message does not contain an indy proof request.');
        }
        return this.proofService.getRequestedCredentialsForProofRequest(indyProofRequest, presentationPreview);
    }
    /**
     * Takes a RetrievedCredentials object and auto selects credentials in a RequestedCredentials object
     *
     * Use the return value of this method as input to {@link ProofService.createPresentation} to
     * automatically accept a received presentation request.
     *
     * @param retrievedCredentials The retrieved credentials object to get credentials from
     *
     * @returns RequestedCredentials
     */
    autoSelectCredentialsForProofRequest(retrievedCredentials) {
        return this.proofService.autoSelectCredentialsForProofRequest(retrievedCredentials);
    }
    /**
     * Send problem report message for a proof record
     * @param proofRecordId  The id of the proof record for which to send problem report
     * @param message message to send
     * @returns proof record associated with the proof problem report message
     */
    async sendProblemReport(proofRecordId, message) {
        const record = await this.proofService.getById(proofRecordId);
        if (!record.connectionId) {
            throw new error_1.AriesFrameworkError(`No connectionId found for proof record '${record.id}'.`);
        }
        const connection = await this.connectionService.getById(record.connectionId);
        const presentationProblemReportMessage = new PresentationProblemReportMessage_1.PresentationProblemReportMessage({
            description: {
                en: message,
                code: errors_1.PresentationProblemReportReason.Abandoned,
            },
        });
        presentationProblemReportMessage.setThread({
            threadId: record.threadId,
        });
        const outboundMessage = helpers_1.createOutboundMessage(connection, presentationProblemReportMessage);
        await this.messageSender.sendMessage(outboundMessage);
        return record;
    }
    /**
     * Retrieve all proof records
     *
     * @returns List containing all proof records
     */
    getAll() {
        return this.proofService.getAll();
    }
    /**
     * Retrieve a proof record by id
     *
     * @param proofRecordId The proof record id
     * @throws {RecordNotFoundError} If no record is found
     * @throws {RecordDuplicateError} If multiple records are found
     * @return The proof record
     *
     */
    async getById(proofRecordId) {
        return this.proofService.getById(proofRecordId);
    }
    /**
     * Retrieve a proof record by id
     *
     * @param proofRecordId The proof record id
     * @return The proof record or null if not found
     *
     */
    async findById(proofRecordId) {
        return this.proofService.findById(proofRecordId);
    }
    /**
     * Delete a proof record by id
     *
     * @param proofId the proof record id
     */
    async deleteById(proofId) {
        return this.proofService.deleteById(proofId);
    }
    registerHandlers(dispatcher) {
        dispatcher.registerHandler(new handlers_1.ProposePresentationHandler(this.proofService, this.agentConfig, this.proofResponseCoordinator));
        dispatcher.registerHandler(new handlers_1.RequestPresentationHandler(this.proofService, this.agentConfig, this.proofResponseCoordinator, this.mediationRecipientService));
        dispatcher.registerHandler(new handlers_1.PresentationHandler(this.proofService, this.agentConfig, this.proofResponseCoordinator));
        dispatcher.registerHandler(new handlers_1.PresentationAckHandler(this.proofService));
        dispatcher.registerHandler(new handlers_1.PresentationProblemReportHandler(this.proofService));
    }
};
ProofsModule = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __metadata("design:paramtypes", [Dispatcher_1.Dispatcher,
        services_1.ProofService,
        ConnectionService_1.ConnectionService,
        MediationRecipientService_1.MediationRecipientService,
        AgentConfig_1.AgentConfig,
        MessageSender_1.MessageSender,
        ProofResponseCoordinator_1.ProofResponseCoordinator])
], ProofsModule);
exports.ProofsModule = ProofsModule;
//# sourceMappingURL=ProofsModule.js.map
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialService = void 0;
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../../agent/AgentConfig");
const EventEmitter_1 = require("../../../agent/EventEmitter");
const Attachment_1 = require("../../../decorators/attachment/Attachment");
const error_1 = require("../../../error");
const JsonEncoder_1 = require("../../../utils/JsonEncoder");
const attachment_1 = require("../../../utils/attachment");
const uuid_1 = require("../../../utils/uuid");
const common_1 = require("../../common");
const ConnectionService_1 = require("../../connections/services/ConnectionService");
const indy_1 = require("../../indy");
const IndyLedgerService_1 = require("../../ledger/services/IndyLedgerService");
const CredentialEvents_1 = require("../CredentialEvents");
const CredentialState_1 = require("../CredentialState");
const CredentialUtils_1 = require("../CredentialUtils");
const errors_1 = require("../errors");
const messages_1 = require("../messages");
const repository_1 = require("../repository");
const CredentialRecord_1 = require("../repository/CredentialRecord");
const credentialMetadataTypes_1 = require("../repository/credentialMetadataTypes");
let CredentialService = class CredentialService {
    constructor(credentialRepository, connectionService, ledgerService, agentConfig, indyIssuerService, indyHolderService, eventEmitter) {
        this.credentialRepository = credentialRepository;
        this.connectionService = connectionService;
        this.ledgerService = ledgerService;
        this.logger = agentConfig.logger;
        this.indyIssuerService = indyIssuerService;
        this.indyHolderService = indyHolderService;
        this.eventEmitter = eventEmitter;
    }
    /**
     * Create a {@link ProposeCredentialMessage} not bound to an existing credential exchange.
     * To create a proposal as response to an existing credential exchange, use {@link CredentialService#createProposalAsResponse}.
     *
     * @param connectionRecord The connection for which to create the credential proposal
     * @param config Additional configuration to use for the proposal
     * @returns Object containing proposal message and associated credential record
     *
     */
    async createProposal(connectionRecord, config) {
        var _a, _b, _c;
        // Assert
        connectionRecord.assertReady();
        const options = Object.assign({}, config);
        // Add the linked attachments to the credentialProposal
        if (config === null || config === void 0 ? void 0 : config.linkedAttachments) {
            options.credentialProposal = CredentialUtils_1.CredentialUtils.createAndLinkAttachmentsToPreview(config.linkedAttachments, (_a = config.credentialProposal) !== null && _a !== void 0 ? _a : new messages_1.CredentialPreview({ attributes: [] }));
            options.attachments = config.linkedAttachments.map((linkedAttachment) => linkedAttachment.attachment);
        }
        // Create message
        const proposalMessage = new messages_1.ProposeCredentialMessage(options !== null && options !== void 0 ? options : {});
        // Create record
        const credentialRecord = new CredentialRecord_1.CredentialRecord({
            connectionId: connectionRecord.id,
            threadId: proposalMessage.threadId,
            state: CredentialState_1.CredentialState.ProposalSent,
            proposalMessage,
            linkedAttachments: (_b = config === null || config === void 0 ? void 0 : config.linkedAttachments) === null || _b === void 0 ? void 0 : _b.map((linkedAttachment) => linkedAttachment.attachment),
            credentialAttributes: (_c = proposalMessage.credentialProposal) === null || _c === void 0 ? void 0 : _c.attributes,
            autoAcceptCredential: config === null || config === void 0 ? void 0 : config.autoAcceptCredential,
        });
        // Set the metadata
        credentialRecord.metadata.set(credentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
            schemaId: options.schemaId,
            credentialDefinitionId: options.credentialDefinitionId,
        });
        await this.credentialRepository.save(credentialRecord);
        this.eventEmitter.emit({
            type: CredentialEvents_1.CredentialEventTypes.CredentialStateChanged,
            payload: {
                credentialRecord,
                previousState: null,
            },
        });
        return { message: proposalMessage, credentialRecord };
    }
    /**
     * Create a {@link ProposePresentationMessage} as response to a received credential offer.
     * To create a proposal not bound to an existing credential exchange, use {@link CredentialService#createProposal}.
     *
     * @param credentialRecord The credential record for which to create the credential proposal
     * @param config Additional configuration to use for the proposal
     * @returns Object containing proposal message and associated credential record
     *
     */
    async createProposalAsResponse(credentialRecord, config) {
        var _a;
        // Assert
        credentialRecord.assertState(CredentialState_1.CredentialState.OfferReceived);
        // Create message
        const proposalMessage = new messages_1.ProposeCredentialMessage(config !== null && config !== void 0 ? config : {});
        proposalMessage.setThread({ threadId: credentialRecord.threadId });
        // Update record
        credentialRecord.proposalMessage = proposalMessage;
        credentialRecord.credentialAttributes = (_a = proposalMessage.credentialProposal) === null || _a === void 0 ? void 0 : _a.attributes;
        this.updateState(credentialRecord, CredentialState_1.CredentialState.ProposalSent);
        return { message: proposalMessage, credentialRecord };
    }
    /**
     * Process a received {@link ProposeCredentialMessage}. This will not accept the credential proposal
     * or send a credential offer. It will only create a new, or update the existing credential record with
     * the information from the credential proposal message. Use {@link CredentialService#createOfferAsResponse}
     * after calling this method to create a credential offer.
     *
     * @param messageContext The message context containing a credential proposal message
     * @returns credential record associated with the credential proposal message
     *
     */
    async processProposal(messageContext) {
        var _a;
        let credentialRecord;
        const { message: proposalMessage, connection } = messageContext;
        this.logger.debug(`Processing credential proposal with id ${proposalMessage.id}`);
        try {
            // Credential record already exists
            credentialRecord = await this.getByThreadAndConnectionId(proposalMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
            // Assert
            credentialRecord.assertState(CredentialState_1.CredentialState.OfferSent);
            this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
                previousReceivedMessage: credentialRecord.proposalMessage,
                previousSentMessage: credentialRecord.offerMessage,
            });
            // Update record
            credentialRecord.proposalMessage = proposalMessage;
            await this.updateState(credentialRecord, CredentialState_1.CredentialState.ProposalReceived);
        }
        catch (_b) {
            // No credential record exists with thread id
            credentialRecord = new CredentialRecord_1.CredentialRecord({
                connectionId: connection === null || connection === void 0 ? void 0 : connection.id,
                threadId: proposalMessage.threadId,
                proposalMessage,
                credentialAttributes: (_a = proposalMessage.credentialProposal) === null || _a === void 0 ? void 0 : _a.attributes,
                state: CredentialState_1.CredentialState.ProposalReceived,
            });
            credentialRecord.metadata.set(credentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
                schemaId: proposalMessage.schemaId,
                credentialDefinitionId: proposalMessage.credentialDefinitionId,
            });
            // Assert
            this.connectionService.assertConnectionOrServiceDecorator(messageContext);
            // Save record
            await this.credentialRepository.save(credentialRecord);
            this.eventEmitter.emit({
                type: CredentialEvents_1.CredentialEventTypes.CredentialStateChanged,
                payload: {
                    credentialRecord,
                    previousState: null,
                },
            });
        }
        return credentialRecord;
    }
    /**
     * Create a {@link OfferCredentialMessage} as response to a received credential proposal.
     * To create an offer not bound to an existing credential exchange, use {@link CredentialService#createOffer}.
     *
     * @param credentialRecord The credential record for which to create the credential offer
     * @param credentialTemplate The credential template to use for the offer
     * @returns Object containing offer message and associated credential record
     *
     */
    async createOfferAsResponse(credentialRecord, credentialTemplate) {
        var _a;
        // Assert
        credentialRecord.assertState(CredentialState_1.CredentialState.ProposalReceived);
        // Create message
        const { credentialDefinitionId, comment, preview, attachments } = credentialTemplate;
        const credOffer = await this.indyIssuerService.createCredentialOffer(credentialDefinitionId);
        const offerAttachment = new Attachment_1.Attachment({
            id: messages_1.INDY_CREDENTIAL_OFFER_ATTACHMENT_ID,
            mimeType: 'application/json',
            data: new Attachment_1.AttachmentData({
                base64: JsonEncoder_1.JsonEncoder.toBase64(credOffer),
            }),
        });
        const credentialOfferMessage = new messages_1.OfferCredentialMessage({
            comment,
            offerAttachments: [offerAttachment],
            credentialPreview: preview,
            attachments,
        });
        credentialOfferMessage.setThread({
            threadId: credentialRecord.threadId,
        });
        credentialRecord.offerMessage = credentialOfferMessage;
        credentialRecord.credentialAttributes = preview.attributes;
        credentialRecord.metadata.set(credentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
            schemaId: credOffer.schema_id,
            credentialDefinitionId: credOffer.cred_def_id,
        });
        credentialRecord.linkedAttachments = attachments === null || attachments === void 0 ? void 0 : attachments.filter((attachment) => attachment_1.isLinkedAttachment(attachment));
        credentialRecord.autoAcceptCredential =
            (_a = credentialTemplate.autoAcceptCredential) !== null && _a !== void 0 ? _a : credentialRecord.autoAcceptCredential;
        await this.updateState(credentialRecord, CredentialState_1.CredentialState.OfferSent);
        return { message: credentialOfferMessage, credentialRecord };
    }
    /**
     * Create a {@link OfferCredentialMessage} not bound to an existing credential exchange.
     * To create an offer as response to an existing credential exchange, use {@link CredentialService#createOfferAsResponse}.
     *
     * @param connectionRecord The connection for which to create the credential offer
     * @param credentialTemplate The credential template to use for the offer
     * @returns Object containing offer message and associated credential record
     *
     */
    async createOffer(credentialTemplate, connectionRecord) {
        // Assert
        connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.assertReady();
        // Create message
        const { credentialDefinitionId, comment, preview, linkedAttachments } = credentialTemplate;
        const credOffer = await this.indyIssuerService.createCredentialOffer(credentialDefinitionId);
        const offerAttachment = new Attachment_1.Attachment({
            id: messages_1.INDY_CREDENTIAL_OFFER_ATTACHMENT_ID,
            mimeType: 'application/json',
            data: new Attachment_1.AttachmentData({
                base64: JsonEncoder_1.JsonEncoder.toBase64(credOffer),
            }),
        });
        // Create and link credential to attacment
        const credentialPreview = linkedAttachments
            ? CredentialUtils_1.CredentialUtils.createAndLinkAttachmentsToPreview(linkedAttachments, preview)
            : preview;
        // Construct offer message
        const credentialOfferMessage = new messages_1.OfferCredentialMessage({
            comment,
            offerAttachments: [offerAttachment],
            credentialPreview,
            attachments: linkedAttachments === null || linkedAttachments === void 0 ? void 0 : linkedAttachments.map((linkedAttachment) => linkedAttachment.attachment),
        });
        // Create record
        const credentialRecord = new CredentialRecord_1.CredentialRecord({
            connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id,
            threadId: credentialOfferMessage.id,
            offerMessage: credentialOfferMessage,
            credentialAttributes: credentialPreview.attributes,
            linkedAttachments: linkedAttachments === null || linkedAttachments === void 0 ? void 0 : linkedAttachments.map((linkedAttachments) => linkedAttachments.attachment),
            state: CredentialState_1.CredentialState.OfferSent,
            autoAcceptCredential: credentialTemplate.autoAcceptCredential,
        });
        credentialRecord.metadata.set(credentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
            credentialDefinitionId: credOffer.cred_def_id,
            schemaId: credOffer.schema_id,
        });
        await this.credentialRepository.save(credentialRecord);
        this.eventEmitter.emit({
            type: CredentialEvents_1.CredentialEventTypes.CredentialStateChanged,
            payload: {
                credentialRecord,
                previousState: null,
            },
        });
        return { message: credentialOfferMessage, credentialRecord };
    }
    /**
     * Process a received {@link OfferCredentialMessage}. This will not accept the credential offer
     * or send a credential request. It will only create a new credential record with
     * the information from the credential offer message. Use {@link CredentialService#createRequest}
     * after calling this method to create a credential request.
     *
     * @param messageContext The message context containing a credential request message
     * @returns credential record associated with the credential offer message
     *
     */
    async processOffer(messageContext) {
        var _a;
        let credentialRecord;
        const { message: credentialOfferMessage, connection } = messageContext;
        this.logger.debug(`Processing credential offer with id ${credentialOfferMessage.id}`);
        const indyCredentialOffer = credentialOfferMessage.indyCredentialOffer;
        if (!indyCredentialOffer) {
            throw new errors_1.CredentialProblemReportError(`Missing required base64 or json encoded attachment data for credential offer with thread id ${credentialOfferMessage.threadId}`, { problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned });
        }
        try {
            // Credential record already exists
            credentialRecord = await this.getByThreadAndConnectionId(credentialOfferMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
            // Assert
            credentialRecord.assertState(CredentialState_1.CredentialState.ProposalSent);
            this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
                previousReceivedMessage: credentialRecord.offerMessage,
                previousSentMessage: credentialRecord.proposalMessage,
            });
            credentialRecord.offerMessage = credentialOfferMessage;
            credentialRecord.linkedAttachments = (_a = credentialOfferMessage.attachments) === null || _a === void 0 ? void 0 : _a.filter(attachment_1.isLinkedAttachment);
            credentialRecord.metadata.set(credentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
                schemaId: indyCredentialOffer.schema_id,
                credentialDefinitionId: indyCredentialOffer.cred_def_id,
            });
            await this.updateState(credentialRecord, CredentialState_1.CredentialState.OfferReceived);
        }
        catch (_b) {
            // No credential record exists with thread id
            credentialRecord = new CredentialRecord_1.CredentialRecord({
                connectionId: connection === null || connection === void 0 ? void 0 : connection.id,
                threadId: credentialOfferMessage.id,
                offerMessage: credentialOfferMessage,
                credentialAttributes: credentialOfferMessage.credentialPreview.attributes,
                state: CredentialState_1.CredentialState.OfferReceived,
            });
            credentialRecord.metadata.set(credentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
                schemaId: indyCredentialOffer.schema_id,
                credentialDefinitionId: indyCredentialOffer.cred_def_id,
            });
            // Assert
            this.connectionService.assertConnectionOrServiceDecorator(messageContext);
            // Save in repository
            await this.credentialRepository.save(credentialRecord);
            this.eventEmitter.emit({
                type: CredentialEvents_1.CredentialEventTypes.CredentialStateChanged,
                payload: {
                    credentialRecord,
                    previousState: null,
                },
            });
        }
        return credentialRecord;
    }
    /**
     * Create a {@link RequestCredentialMessage} as response to a received credential offer.
     *
     * @param credentialRecord The credential record for which to create the credential request
     * @param options Additional configuration to use for the credential request
     * @returns Object containing request message and associated credential record
     *
     */
    async createRequest(credentialRecord, options) {
        var _a, _b, _c, _d, _e, _f;
        // Assert credential
        credentialRecord.assertState(CredentialState_1.CredentialState.OfferReceived);
        const credentialOffer = (_a = credentialRecord.offerMessage) === null || _a === void 0 ? void 0 : _a.indyCredentialOffer;
        if (!credentialOffer) {
            throw new errors_1.CredentialProblemReportError(`Missing required base64 or json encoded attachment data for credential offer with thread id ${credentialRecord.threadId}`, { problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned });
        }
        const credentialDefinition = await this.ledgerService.getCredentialDefinition(credentialOffer.cred_def_id);
        const [credReq, credReqMetadata] = await this.indyHolderService.createCredentialRequest({
            holderDid: options.holderDid,
            credentialOffer,
            credentialDefinition,
        });
        const requestAttachment = new Attachment_1.Attachment({
            id: messages_1.INDY_CREDENTIAL_REQUEST_ATTACHMENT_ID,
            mimeType: 'application/json',
            data: new Attachment_1.AttachmentData({
                base64: JsonEncoder_1.JsonEncoder.toBase64(credReq),
            }),
        });
        const credentialRequest = new messages_1.RequestCredentialMessage({
            comment: options === null || options === void 0 ? void 0 : options.comment,
            requestAttachments: [requestAttachment],
            attachments: (_c = (_b = credentialRecord.offerMessage) === null || _b === void 0 ? void 0 : _b.attachments) === null || _c === void 0 ? void 0 : _c.filter((attachment) => attachment_1.isLinkedAttachment(attachment)),
        });
        credentialRequest.setThread({ threadId: credentialRecord.threadId });
        credentialRecord.metadata.set(credentialMetadataTypes_1.CredentialMetadataKeys.IndyRequest, credReqMetadata);
        credentialRecord.requestMessage = credentialRequest;
        credentialRecord.autoAcceptCredential = (_d = options === null || options === void 0 ? void 0 : options.autoAcceptCredential) !== null && _d !== void 0 ? _d : credentialRecord.autoAcceptCredential;
        credentialRecord.linkedAttachments = (_f = (_e = credentialRecord.offerMessage) === null || _e === void 0 ? void 0 : _e.attachments) === null || _f === void 0 ? void 0 : _f.filter((attachment) => attachment_1.isLinkedAttachment(attachment));
        await this.updateState(credentialRecord, CredentialState_1.CredentialState.RequestSent);
        return { message: credentialRequest, credentialRecord };
    }
    /**
     * Process a received {@link RequestCredentialMessage}. This will not accept the credential request
     * or send a credential. It will only update the existing credential record with
     * the information from the credential request message. Use {@link CredentialService#createCredential}
     * after calling this method to create a credential.
     *
     * @param messageContext The message context containing a credential request message
     * @returns credential record associated with the credential request message
     *
     */
    async processRequest(messageContext) {
        const { message: credentialRequestMessage, connection } = messageContext;
        this.logger.debug(`Processing credential request with id ${credentialRequestMessage.id}`);
        const indyCredentialRequest = credentialRequestMessage === null || credentialRequestMessage === void 0 ? void 0 : credentialRequestMessage.indyCredentialRequest;
        if (!indyCredentialRequest) {
            throw new errors_1.CredentialProblemReportError(`Missing required base64 or json encoded attachment data for credential request with thread id ${credentialRequestMessage.threadId}`, { problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned });
        }
        const credentialRecord = await this.getByThreadAndConnectionId(credentialRequestMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        // Assert
        credentialRecord.assertState(CredentialState_1.CredentialState.OfferSent);
        this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: credentialRecord.proposalMessage,
            previousSentMessage: credentialRecord.offerMessage,
        });
        this.logger.debug('Credential record found when processing credential request', credentialRecord);
        credentialRecord.requestMessage = credentialRequestMessage;
        await this.updateState(credentialRecord, CredentialState_1.CredentialState.RequestReceived);
        return credentialRecord;
    }
    /**
     * Create a {@link IssueCredentialMessage} as response to a received credential request.
     *
     * @param credentialRecord The credential record for which to create the credential
     * @param options Additional configuration to use for the credential
     * @returns Object containing issue credential message and associated credential record
     *
     */
    async createCredential(credentialRecord, options) {
        var _a, _b, _c;
        // Assert
        credentialRecord.assertState(CredentialState_1.CredentialState.RequestReceived);
        const requestMessage = credentialRecord.requestMessage;
        const offerMessage = credentialRecord.offerMessage;
        // Assert offer message
        if (!offerMessage) {
            throw new error_1.AriesFrameworkError(`Missing credential offer for credential exchange with thread id ${credentialRecord.threadId}`);
        }
        // Assert credential attributes
        const credentialAttributes = credentialRecord.credentialAttributes;
        if (!credentialAttributes) {
            throw new errors_1.CredentialProblemReportError(`Missing required credential attribute values on credential record with id ${credentialRecord.id}`, { problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned });
        }
        // Assert Indy offer
        const indyCredentialOffer = offerMessage === null || offerMessage === void 0 ? void 0 : offerMessage.indyCredentialOffer;
        if (!indyCredentialOffer) {
            throw new errors_1.CredentialProblemReportError(`Missing required base64 or json encoded attachment data for credential offer with thread id ${credentialRecord.threadId}`, { problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned });
        }
        // Assert Indy request
        const indyCredentialRequest = requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.indyCredentialRequest;
        if (!indyCredentialRequest) {
            throw new errors_1.CredentialProblemReportError(`Missing required base64 or json encoded attachment data for credential request with thread id ${credentialRecord.threadId}`, { problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned });
        }
        const [credential] = await this.indyIssuerService.createCredential({
            credentialOffer: indyCredentialOffer,
            credentialRequest: indyCredentialRequest,
            credentialValues: CredentialUtils_1.CredentialUtils.convertAttributesToValues(credentialAttributes),
        });
        const credentialAttachment = new Attachment_1.Attachment({
            id: messages_1.INDY_CREDENTIAL_ATTACHMENT_ID,
            mimeType: 'application/json',
            data: new Attachment_1.AttachmentData({
                base64: JsonEncoder_1.JsonEncoder.toBase64(credential),
            }),
        });
        const issueCredentialMessage = new messages_1.IssueCredentialMessage({
            comment: options === null || options === void 0 ? void 0 : options.comment,
            credentialAttachments: [credentialAttachment],
            attachments: ((_a = offerMessage === null || offerMessage === void 0 ? void 0 : offerMessage.attachments) === null || _a === void 0 ? void 0 : _a.filter((attachment) => attachment_1.isLinkedAttachment(attachment))) ||
                ((_b = requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.attachments) === null || _b === void 0 ? void 0 : _b.filter((attachment) => attachment_1.isLinkedAttachment(attachment))),
        });
        issueCredentialMessage.setThread({
            threadId: credentialRecord.threadId,
        });
        issueCredentialMessage.setPleaseAck();
        credentialRecord.credentialMessage = issueCredentialMessage;
        credentialRecord.autoAcceptCredential = (_c = options === null || options === void 0 ? void 0 : options.autoAcceptCredential) !== null && _c !== void 0 ? _c : credentialRecord.autoAcceptCredential;
        await this.updateState(credentialRecord, CredentialState_1.CredentialState.CredentialIssued);
        return { message: issueCredentialMessage, credentialRecord };
    }
    /**
     * Process a received {@link IssueCredentialMessage}. This will not accept the credential
     * or send a credential acknowledgement. It will only update the existing credential record with
     * the information from the issue credential message. Use {@link CredentialService#createAck}
     * after calling this method to create a credential acknowledgement.
     *
     * @param messageContext The message context containing an issue credential message
     *
     * @returns credential record associated with the issue credential message
     *
     */
    async processCredential(messageContext) {
        const { message: issueCredentialMessage, connection } = messageContext;
        this.logger.debug(`Processing credential with id ${issueCredentialMessage.id}`);
        const credentialRecord = await this.getByThreadAndConnectionId(issueCredentialMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        // Assert
        credentialRecord.assertState(CredentialState_1.CredentialState.RequestSent);
        this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: credentialRecord.offerMessage,
            previousSentMessage: credentialRecord.requestMessage,
        });
        const credentialRequestMetadata = credentialRecord.metadata.get(credentialMetadataTypes_1.CredentialMetadataKeys.IndyRequest);
        if (!credentialRequestMetadata) {
            throw new errors_1.CredentialProblemReportError(`Missing required request metadata for credential with id ${credentialRecord.id}`, { problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned });
        }
        const indyCredential = issueCredentialMessage.indyCredential;
        if (!indyCredential) {
            throw new errors_1.CredentialProblemReportError(`Missing required base64 or json encoded attachment data for credential with thread id ${issueCredentialMessage.threadId}`, { problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned });
        }
        const credentialDefinition = await this.ledgerService.getCredentialDefinition(indyCredential.cred_def_id);
        const credentialId = await this.indyHolderService.storeCredential({
            credentialId: uuid_1.uuid(),
            credentialRequestMetadata,
            credential: indyCredential,
            credentialDefinition,
        });
        credentialRecord.credentialId = credentialId;
        credentialRecord.credentialMessage = issueCredentialMessage;
        await this.updateState(credentialRecord, CredentialState_1.CredentialState.CredentialReceived);
        return credentialRecord;
    }
    /**
     * Create a {@link CredentialAckMessage} as response to a received credential.
     *
     * @param credentialRecord The credential record for which to create the credential acknowledgement
     * @returns Object containing credential acknowledgement message and associated credential record
     *
     */
    async createAck(credentialRecord) {
        credentialRecord.assertState(CredentialState_1.CredentialState.CredentialReceived);
        // Create message
        const ackMessage = new messages_1.CredentialAckMessage({
            status: common_1.AckStatus.OK,
            threadId: credentialRecord.threadId,
        });
        await this.updateState(credentialRecord, CredentialState_1.CredentialState.Done);
        return { message: ackMessage, credentialRecord };
    }
    /**
     * Decline a credential offer
     * @param credentialRecord The credential to be declined
     */
    async declineOffer(credentialRecord) {
        credentialRecord.assertState(CredentialState_1.CredentialState.OfferReceived);
        await this.updateState(credentialRecord, CredentialState_1.CredentialState.Declined);
        return credentialRecord;
    }
    /**
     * Process a received {@link CredentialAckMessage}.
     *
     * @param messageContext The message context containing a credential acknowledgement message
     * @returns credential record associated with the credential acknowledgement message
     *
     */
    async processAck(messageContext) {
        const { message: credentialAckMessage, connection } = messageContext;
        this.logger.debug(`Processing credential ack with id ${credentialAckMessage.id}`);
        const credentialRecord = await this.getByThreadAndConnectionId(credentialAckMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        // Assert
        credentialRecord.assertState(CredentialState_1.CredentialState.CredentialIssued);
        this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: credentialRecord.requestMessage,
            previousSentMessage: credentialRecord.credentialMessage,
        });
        // Update record
        await this.updateState(credentialRecord, CredentialState_1.CredentialState.Done);
        return credentialRecord;
    }
    /**
     * Process a received {@link ProblemReportMessage}.
     *
     * @param messageContext The message context containing a credential problem report message
     * @returns credential record associated with the credential problem report message
     *
     */
    async processProblemReport(messageContext) {
        const { message: credentialProblemReportMessage } = messageContext;
        const connection = messageContext.assertReadyConnection();
        this.logger.debug(`Processing problem report with id ${credentialProblemReportMessage.id}`);
        const credentialRecord = await this.getByThreadAndConnectionId(credentialProblemReportMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        // Update record
        credentialRecord.errorMessage = `${credentialProblemReportMessage.description.code}: ${credentialProblemReportMessage.description.en}`;
        await this.update(credentialRecord);
        return credentialRecord;
    }
    /**
     * Retrieve all credential records
     *
     * @returns List containing all credential records
     */
    getAll() {
        return this.credentialRepository.getAll();
    }
    /**
     * Retrieve a credential record by id
     *
     * @param credentialRecordId The credential record id
     * @throws {RecordNotFoundError} If no record is found
     * @return The credential record
     *
     */
    getById(credentialRecordId) {
        return this.credentialRepository.getById(credentialRecordId);
    }
    /**
     * Find a credential record by id
     *
     * @param credentialRecordId the credential record id
     * @returns The credential record or null if not found
     */
    findById(connectionId) {
        return this.credentialRepository.findById(connectionId);
    }
    /**
     * Delete a credential record by id
     *
     * @param credentialId the credential record id
     */
    async deleteById(credentialId) {
        const credentialRecord = await this.getById(credentialId);
        return this.credentialRepository.delete(credentialRecord);
    }
    /**
     * Retrieve a credential record by connection id and thread id
     *
     * @param connectionId The connection id
     * @param threadId The thread id
     * @throws {RecordNotFoundError} If no record is found
     * @throws {RecordDuplicateError} If multiple records are found
     * @returns The credential record
     */
    getByThreadAndConnectionId(threadId, connectionId) {
        return this.credentialRepository.getSingleByQuery({
            connectionId,
            threadId,
        });
    }
    update(credentialRecord) {
        return this.credentialRepository.update(credentialRecord);
    }
    /**
     * Update the record to a new state and emit an state changed event. Also updates the record
     * in storage.
     *
     * @param credentialRecord The credential record to update the state for
     * @param newState The state to update to
     *
     */
    async updateState(credentialRecord, newState) {
        const previousState = credentialRecord.state;
        credentialRecord.state = newState;
        await this.credentialRepository.update(credentialRecord);
        this.eventEmitter.emit({
            type: CredentialEvents_1.CredentialEventTypes.CredentialStateChanged,
            payload: {
                credentialRecord,
                previousState: previousState,
            },
        });
    }
};
CredentialService = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __metadata("design:paramtypes", [repository_1.CredentialRepository,
        ConnectionService_1.ConnectionService,
        IndyLedgerService_1.IndyLedgerService,
        AgentConfig_1.AgentConfig,
        indy_1.IndyIssuerService,
        indy_1.IndyHolderService,
        EventEmitter_1.EventEmitter])
], CredentialService);
exports.CredentialService = CredentialService;
//# sourceMappingURL=CredentialService.js.map
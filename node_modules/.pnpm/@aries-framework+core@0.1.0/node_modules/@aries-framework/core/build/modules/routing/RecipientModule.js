"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecipientModule = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../agent/AgentConfig");
const Dispatcher_1 = require("../../agent/Dispatcher");
const EventEmitter_1 = require("../../agent/EventEmitter");
const MessageSender_1 = require("../../agent/MessageSender");
const helpers_1 = require("../../agent/helpers");
const error_1 = require("../../error");
const transport_1 = require("../../transport");
const connections_1 = require("../connections");
const services_1 = require("../connections/services");
const MediatorPickupStrategy_1 = require("./MediatorPickupStrategy");
const RoutingEvents_1 = require("./RoutingEvents");
const KeylistUpdateResponseHandler_1 = require("./handlers/KeylistUpdateResponseHandler");
const MediationDenyHandler_1 = require("./handlers/MediationDenyHandler");
const MediationGrantHandler_1 = require("./handlers/MediationGrantHandler");
const BatchPickupMessage_1 = require("./messages/BatchPickupMessage");
const MediationState_1 = require("./models/MediationState");
const MediationRecipientService_1 = require("./services/MediationRecipientService");
let RecipientModule = class RecipientModule {
    constructor(dispatcher, agentConfig, mediationRecipientService, connectionService, messageSender, eventEmitter) {
        this.agentConfig = agentConfig;
        this.connectionService = connectionService;
        this.mediationRecipientService = mediationRecipientService;
        this.messageSender = messageSender;
        this.eventEmitter = eventEmitter;
        this.logger = agentConfig.logger;
        this.registerHandlers(dispatcher);
    }
    async initialize() {
        const { defaultMediatorId, clearDefaultMediator } = this.agentConfig;
        // Set default mediator by id
        if (defaultMediatorId) {
            const mediatorRecord = await this.mediationRecipientService.getById(defaultMediatorId);
            await this.mediationRecipientService.setDefaultMediator(mediatorRecord);
        }
        // Clear the stored default mediator
        else if (clearDefaultMediator) {
            await this.mediationRecipientService.clearDefaultMediator();
        }
        // Poll for messages from mediator
        const defaultMediator = await this.findDefaultMediator();
        if (defaultMediator) {
            await this.initiateMessagePickup(defaultMediator);
        }
    }
    async sendMessage(outboundMessage) {
        const { mediatorPickupStrategy } = this.agentConfig;
        const transportPriority = mediatorPickupStrategy === MediatorPickupStrategy_1.MediatorPickupStrategy.Implicit
            ? { schemes: ['wss', 'ws'], restrictive: true }
            : undefined;
        await this.messageSender.sendMessage(outboundMessage, {
            transportPriority,
            // TODO: add keepAlive: true to enforce through the public api
            // we need to keep the socket alive. It already works this way, but would
            // be good to make more explicit from the public facing API.
            // This would also make it easier to change the internal API later on.
            // keepAlive: true,
        });
    }
    async openMediationWebSocket(mediator) {
        var _a, _b;
        const { message, connectionRecord } = await this.connectionService.createTrustPing(mediator.connectionId, {
            responseRequested: false,
        });
        const websocketSchemes = ['ws', 'wss'];
        const hasWebSocketTransport = (_b = (_a = connectionRecord.theirDidDoc) === null || _a === void 0 ? void 0 : _a.didCommServices) === null || _b === void 0 ? void 0 : _b.some((s) => websocketSchemes.includes(s.protocolScheme));
        if (!hasWebSocketTransport) {
            throw new error_1.AriesFrameworkError('Cannot open websocket to connection without websocket service endpoint');
        }
        try {
            await this.messageSender.sendMessage(helpers_1.createOutboundMessage(connectionRecord, message), {
                transportPriority: {
                    schemes: websocketSchemes,
                    restrictive: true,
                    // TODO: add keepAlive: true to enforce through the public api
                    // we need to keep the socket alive. It already works this way, but would
                    // be good to make more explicit from the public facing API.
                    // This would also make it easier to change the internal API later on.
                    // keepAlive: true,
                },
            });
        }
        catch (error) {
            this.logger.warn('Unable to open websocket connection to mediator', { error });
        }
    }
    async initiateImplicitPickup(mediator) {
        let interval = 50;
        // Listens to Outbound websocket closed events and will reopen the websocket connection
        // in a recursive back off strategy if it matches the following criteria:
        // - Agent is not shutdown
        // - Socket was for current mediator connection id
        this.eventEmitter
            .observable(transport_1.TransportEventTypes.OutboundWebSocketClosedEvent)
            .pipe(
        // Stop when the agent shuts down
        operators_1.takeUntil(this.agentConfig.stop$), operators_1.filter((e) => e.payload.connectionId === mediator.connectionId), 
        // Make sure we're not reconnecting multiple times
        operators_1.throttleTime(interval), 
        // Increase the interval (recursive back-off)
        operators_1.tap(() => (interval *= 2)), 
        // Wait for interval time before reconnecting
        operators_1.delay(interval))
            .subscribe(async () => {
            this.logger.warn(`Websocket connection to mediator with connectionId '${mediator.connectionId}' is closed, attempting to reconnect...`);
            this.openMediationWebSocket(mediator);
        });
        await this.openMediationWebSocket(mediator);
    }
    async initiateMessagePickup(mediator) {
        const { mediatorPickupStrategy, mediatorPollingInterval } = this.agentConfig;
        const mediatorConnection = await this.connectionService.getById(mediator.connectionId);
        // Explicit means polling every X seconds with batch message
        if (mediatorPickupStrategy === MediatorPickupStrategy_1.MediatorPickupStrategy.Explicit) {
            this.agentConfig.logger.info(`Starting explicit (batch) pickup of messages from mediator '${mediator.id}'`);
            const subscription = rxjs_1.interval(mediatorPollingInterval)
                .pipe(operators_1.takeUntil(this.agentConfig.stop$))
                .subscribe(async () => {
                await this.pickupMessages(mediatorConnection);
            });
            return subscription;
        }
        // Implicit means sending ping once and keeping connection open. This requires a long-lived transport
        // such as WebSockets to work
        else if (mediatorPickupStrategy === MediatorPickupStrategy_1.MediatorPickupStrategy.Implicit) {
            this.agentConfig.logger.info(`Starting implicit pickup of messages from mediator '${mediator.id}'`);
            await this.initiateImplicitPickup(mediator);
        }
        else {
            this.agentConfig.logger.info(`Skipping pickup of messages from mediator '${mediator.id}' due to pickup strategy none`);
        }
    }
    async discoverMediation() {
        return this.mediationRecipientService.discoverMediation();
    }
    async pickupMessages(mediatorConnection) {
        mediatorConnection.assertReady();
        const batchPickupMessage = new BatchPickupMessage_1.BatchPickupMessage({ batchSize: 10 });
        const outboundMessage = helpers_1.createOutboundMessage(mediatorConnection, batchPickupMessage);
        await this.sendMessage(outboundMessage);
    }
    async setDefaultMediator(mediatorRecord) {
        return this.mediationRecipientService.setDefaultMediator(mediatorRecord);
    }
    async requestMediation(connection) {
        const { mediationRecord, message } = await this.mediationRecipientService.createRequest(connection);
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.sendMessage(outboundMessage);
        return mediationRecord;
    }
    async notifyKeylistUpdate(connection, verkey) {
        const message = this.mediationRecipientService.createKeylistUpdateMessage(verkey);
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.sendMessage(outboundMessage);
    }
    async findByConnectionId(connectionId) {
        return await this.mediationRecipientService.findByConnectionId(connectionId);
    }
    async getMediators() {
        return await this.mediationRecipientService.getMediators();
    }
    async findDefaultMediator() {
        return this.mediationRecipientService.findDefaultMediator();
    }
    async findDefaultMediatorConnection() {
        const mediatorRecord = await this.findDefaultMediator();
        if (mediatorRecord) {
            return this.connectionService.getById(mediatorRecord.connectionId);
        }
        return null;
    }
    async requestAndAwaitGrant(connection, timeoutMs = 10000) {
        const { mediationRecord, message } = await this.mediationRecipientService.createRequest(connection);
        // Create observable for event
        const observable = this.eventEmitter.observable(RoutingEvents_1.RoutingEventTypes.MediationStateChanged);
        const subject = new rxjs_1.ReplaySubject(1);
        // Apply required filters to observable stream subscribe to replay subject
        observable
            .pipe(
        // Only take event for current mediation record
        operators_1.filter((event) => event.payload.mediationRecord.id === mediationRecord.id), 
        // Only take event for previous state requested, current state granted
        operators_1.filter((event) => event.payload.previousState === MediationState_1.MediationState.Requested), operators_1.filter((event) => event.payload.mediationRecord.state === MediationState_1.MediationState.Granted), 
        // Only wait for first event that matches the criteria
        operators_1.first(), 
        // Do not wait for longer than specified timeout
        operators_1.timeout(timeoutMs))
            .subscribe(subject);
        // Send mediation request message
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.sendMessage(outboundMessage);
        const event = await rxjs_1.firstValueFrom(subject);
        return event.payload.mediationRecord;
    }
    async provision(mediatorConnInvite) {
        this.logger.debug('Provision Mediation with invitation', { invite: mediatorConnInvite });
        // Connect to mediator through provided invitation
        // Also requests mediation and sets as default mediator
        // Assumption: processInvitation is a URL-encoded invitation
        const invitation = await connections_1.ConnectionInvitationMessage.fromUrl(mediatorConnInvite);
        // Check if invitation has been used already
        if (!invitation || !invitation.recipientKeys || !invitation.recipientKeys[0]) {
            throw new error_1.AriesFrameworkError(`Invalid mediation invitation. Invitation must have at least one recipient key.`);
        }
        let mediationRecord = null;
        const connection = await this.connectionService.findByInvitationKey(invitation.recipientKeys[0]);
        if (!connection) {
            this.logger.debug('Mediation Connection does not exist, creating connection');
            // We don't want to use the current default mediator when connecting to another mediator
            const routing = await this.mediationRecipientService.getRouting({ useDefaultMediator: false });
            const invitationConnectionRecord = await this.connectionService.processInvitation(invitation, {
                autoAcceptConnection: true,
                routing,
            });
            this.logger.debug('Processed mediation invitation', {
                connectionId: invitationConnectionRecord,
            });
            const { message, connectionRecord } = await this.connectionService.createRequest(invitationConnectionRecord.id);
            const outbound = helpers_1.createOutboundMessage(connectionRecord, message);
            await this.messageSender.sendMessage(outbound);
            const completedConnectionRecord = await this.connectionService.returnWhenIsConnected(connectionRecord.id);
            this.logger.debug('Connection completed, requesting mediation');
            mediationRecord = await this.requestAndAwaitGrant(completedConnectionRecord, 60000); // TODO: put timeout as a config parameter
            this.logger.debug('Mediation Granted, setting as default mediator');
            await this.setDefaultMediator(mediationRecord);
            this.logger.debug('Default mediator set');
        }
        else if (connection && !connection.isReady) {
            const connectionRecord = await this.connectionService.returnWhenIsConnected(connection.id);
            mediationRecord = await this.requestAndAwaitGrant(connectionRecord, 60000); // TODO: put timeout as a config parameter
            await this.setDefaultMediator(mediationRecord);
        }
        else {
            this.agentConfig.logger.warn('Mediator Invitation in configuration has already been used to create a connection.');
            const mediator = await this.findByConnectionId(connection.id);
            if (!mediator) {
                this.agentConfig.logger.warn('requesting mediation over connection.');
                mediationRecord = await this.requestAndAwaitGrant(connection, 60000); // TODO: put timeout as a config parameter
                await this.setDefaultMediator(mediationRecord);
            }
            else {
                this.agentConfig.logger.warn(`Mediator Invitation in configuration has already been ${mediator.isReady ? 'granted' : 'requested'} mediation`);
            }
        }
        return mediationRecord;
    }
    // Register handlers for the several messages for the mediator.
    registerHandlers(dispatcher) {
        dispatcher.registerHandler(new KeylistUpdateResponseHandler_1.KeylistUpdateResponseHandler(this.mediationRecipientService));
        dispatcher.registerHandler(new MediationGrantHandler_1.MediationGrantHandler(this.mediationRecipientService));
        dispatcher.registerHandler(new MediationDenyHandler_1.MediationDenyHandler(this.mediationRecipientService));
        //dispatcher.registerHandler(new KeylistListHandler(this.mediationRecipientService)) // TODO: write this
    }
};
RecipientModule = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __metadata("design:paramtypes", [Dispatcher_1.Dispatcher,
        AgentConfig_1.AgentConfig,
        MediationRecipientService_1.MediationRecipientService,
        services_1.ConnectionService,
        MessageSender_1.MessageSender,
        EventEmitter_1.EventEmitter])
], RecipientModule);
exports.RecipientModule = RecipientModule;
//# sourceMappingURL=RecipientModule.js.map
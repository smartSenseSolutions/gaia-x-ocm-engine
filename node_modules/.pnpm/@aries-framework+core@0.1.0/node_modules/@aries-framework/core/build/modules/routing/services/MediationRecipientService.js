"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediationRecipientService = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../../agent/AgentConfig");
const EventEmitter_1 = require("../../../agent/EventEmitter");
const MessageSender_1 = require("../../../agent/MessageSender");
const helpers_1 = require("../../../agent/helpers");
const constants_1 = require("../../../constants");
const error_1 = require("../../../error");
const ConnectionService_1 = require("../../connections/services/ConnectionService");
const RoutingEvents_1 = require("../RoutingEvents");
const messages_1 = require("../messages");
const KeylistUpdateMessage_1 = require("../messages/KeylistUpdateMessage");
const models_1 = require("../models");
const MediationRecord_1 = require("../repository/MediationRecord");
const MediationRepository_1 = require("../repository/MediationRepository");
let MediationRecipientService = class MediationRecipientService {
    constructor(wallet, connectionService, messageSender, config, mediatorRepository, eventEmitter) {
        this.config = config;
        this.wallet = wallet;
        this.mediatorRepository = mediatorRepository;
        this.eventEmitter = eventEmitter;
        this.connectionService = connectionService;
        this.messageSender = messageSender;
    }
    async createRequest(connection) {
        const message = new messages_1.MediationRequestMessage({});
        const mediationRecord = new MediationRecord_1.MediationRecord({
            threadId: message.threadId,
            state: models_1.MediationState.Requested,
            role: models_1.MediationRole.Mediator,
            connectionId: connection.id,
        });
        await this.mediatorRepository.save(mediationRecord);
        this.eventEmitter.emit({
            type: RoutingEvents_1.RoutingEventTypes.MediationStateChanged,
            payload: {
                mediationRecord,
                previousState: null,
            },
        });
        return { mediationRecord, message };
    }
    async processMediationGrant(messageContext) {
        // Assert ready connection
        const connection = messageContext.assertReadyConnection();
        // Mediation record must already exists to be updated to granted status
        const mediationRecord = await this.mediatorRepository.getByConnectionId(connection.id);
        // Assert
        mediationRecord.assertState(models_1.MediationState.Requested);
        // Update record
        mediationRecord.endpoint = messageContext.message.endpoint;
        mediationRecord.routingKeys = messageContext.message.routingKeys;
        return await this.updateState(mediationRecord, models_1.MediationState.Granted);
    }
    async processKeylistUpdateResults(messageContext) {
        // Assert ready connection
        const connection = messageContext.assertReadyConnection();
        const mediationRecord = await this.mediatorRepository.getByConnectionId(connection.id);
        const keylist = messageContext.message.updated;
        // update keylist in mediationRecord
        for (const update of keylist) {
            if (update.action === messages_1.KeylistUpdateAction.add) {
                await this.saveRoute(update.recipientKey, mediationRecord);
            }
            else if (update.action === messages_1.KeylistUpdateAction.remove) {
                await this.removeRoute(update.recipientKey, mediationRecord);
            }
        }
        this.eventEmitter.emit({
            type: RoutingEvents_1.RoutingEventTypes.RecipientKeylistUpdated,
            payload: {
                mediationRecord,
                keylist,
            },
        });
    }
    async keylistUpdateAndAwait(mediationRecord, verKey, timeoutMs = 15000 // TODO: this should be a configurable value in agent config
    ) {
        const message = this.createKeylistUpdateMessage(verKey);
        const connection = await this.connectionService.getById(mediationRecord.connectionId);
        // Create observable for event
        const observable = this.eventEmitter.observable(RoutingEvents_1.RoutingEventTypes.RecipientKeylistUpdated);
        const subject = new rxjs_1.ReplaySubject(1);
        // Apply required filters to observable stream and create promise to subscribe to observable
        observable
            .pipe(
        // Only take event for current mediation record
        operators_1.filter((event) => mediationRecord.id === event.payload.mediationRecord.id), 
        // Only wait for first event that matches the criteria
        operators_1.first(), 
        // Do not wait for longer than specified timeout
        operators_1.timeout(timeoutMs))
            .subscribe(subject);
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.messageSender.sendMessage(outboundMessage);
        const keylistUpdate = await rxjs_1.firstValueFrom(subject);
        return keylistUpdate.payload.mediationRecord;
    }
    createKeylistUpdateMessage(verkey) {
        const keylistUpdateMessage = new KeylistUpdateMessage_1.KeylistUpdateMessage({
            updates: [
                new KeylistUpdateMessage_1.KeylistUpdate({
                    action: messages_1.KeylistUpdateAction.add,
                    recipientKey: verkey,
                }),
            ],
        });
        return keylistUpdateMessage;
    }
    async getRouting({ mediatorId, useDefaultMediator = true } = {}) {
        let mediationRecord = null;
        if (mediatorId) {
            mediationRecord = await this.getById(mediatorId);
        }
        else if (useDefaultMediator) {
            // If no mediatorId is provided, and useDefaultMediator is true (default)
            // We use the default mediator if available
            mediationRecord = await this.findDefaultMediator();
        }
        let endpoints = this.config.endpoints;
        let routingKeys = [];
        // Create and store new key
        const { did, verkey } = await this.wallet.createDid();
        if (mediationRecord) {
            routingKeys = [...routingKeys, ...mediationRecord.routingKeys];
            endpoints = mediationRecord.endpoint ? [mediationRecord.endpoint] : endpoints;
            // new did has been created and mediator needs to be updated with the public key.
            mediationRecord = await this.keylistUpdateAndAwait(mediationRecord, verkey);
        }
        else {
            // TODO: check that recipient keys are in wallet
        }
        return { endpoints, routingKeys, did, verkey, mediatorId: mediationRecord === null || mediationRecord === void 0 ? void 0 : mediationRecord.id };
    }
    async saveRoute(recipientKey, mediationRecord) {
        mediationRecord.recipientKeys.push(recipientKey);
        this.mediatorRepository.update(mediationRecord);
    }
    async removeRoute(recipientKey, mediationRecord) {
        const index = mediationRecord.recipientKeys.indexOf(recipientKey, 0);
        if (index > -1) {
            mediationRecord.recipientKeys.splice(index, 1);
        }
        this.mediatorRepository.update(mediationRecord);
    }
    async processMediationDeny(messageContext) {
        const connection = messageContext.assertReadyConnection();
        // Mediation record already exists
        const mediationRecord = await this.findByConnectionId(connection.id);
        if (!mediationRecord) {
            throw new Error(`No mediation has been requested for this connection id: ${connection.id}`);
        }
        // Assert
        mediationRecord.assertState(models_1.MediationState.Requested);
        // Update record
        await this.updateState(mediationRecord, models_1.MediationState.Denied);
        return mediationRecord;
    }
    /**
     * Update the record to a new state and emit an state changed event. Also updates the record
     * in storage.
     *
     * @param MediationRecord The proof record to update the state for
     * @param newState The state to update to
     *
     */
    async updateState(mediationRecord, newState) {
        const previousState = mediationRecord.state;
        mediationRecord.state = newState;
        await this.mediatorRepository.update(mediationRecord);
        this.eventEmitter.emit({
            type: RoutingEvents_1.RoutingEventTypes.MediationStateChanged,
            payload: {
                mediationRecord,
                previousState,
            },
        });
        return mediationRecord;
    }
    async getById(id) {
        return this.mediatorRepository.getById(id);
    }
    async findByConnectionId(connectionId) {
        return this.mediatorRepository.findSingleByQuery({ connectionId });
    }
    async getMediators() {
        return this.mediatorRepository.getAll();
    }
    async findDefaultMediator() {
        return this.mediatorRepository.findSingleByQuery({ default: true });
    }
    async discoverMediation(mediatorId) {
        // If mediatorId is passed, always use it (and error if it is not found)
        if (mediatorId) {
            return this.mediatorRepository.getById(mediatorId);
        }
        const defaultMediator = await this.findDefaultMediator();
        if (defaultMediator) {
            if (defaultMediator.state !== models_1.MediationState.Granted) {
                throw new error_1.AriesFrameworkError(`Mediation State for ${defaultMediator.id} is not granted, but is set as default mediator!`);
            }
            return defaultMediator;
        }
    }
    async setDefaultMediator(mediator) {
        const mediationRecords = await this.mediatorRepository.findByQuery({ default: true });
        for (const record of mediationRecords) {
            record.setTag('default', false);
            await this.mediatorRepository.update(record);
        }
        // Set record coming in tag to true and then update.
        mediator.setTag('default', true);
        await this.mediatorRepository.update(mediator);
    }
    async clearDefaultMediator() {
        const mediationRecord = await this.findDefaultMediator();
        if (mediationRecord) {
            mediationRecord.setTag('default', false);
            await this.mediatorRepository.update(mediationRecord);
        }
    }
};
MediationRecipientService = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __param(0, tsyringe_1.inject(constants_1.InjectionSymbols.Wallet)),
    __metadata("design:paramtypes", [Object, ConnectionService_1.ConnectionService,
        MessageSender_1.MessageSender,
        AgentConfig_1.AgentConfig,
        MediationRepository_1.MediationRepository,
        EventEmitter_1.EventEmitter])
], MediationRecipientService);
exports.MediationRecipientService = MediationRecipientService;
//# sourceMappingURL=MediationRecipientService.js.map
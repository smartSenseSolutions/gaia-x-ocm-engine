"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndyHolderService = void 0;
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../../agent/AgentConfig");
const error_1 = require("../../../error");
const indyError_1 = require("../../../utils/indyError");
const IndyWallet_1 = require("../../../wallet/IndyWallet");
let IndyHolderService = class IndyHolderService {
    constructor(agentConfig, wallet) {
        this.indy = agentConfig.agentDependencies.indy;
        this.wallet = wallet;
    }
    async createProof({ proofRequest, requestedCredentials, schemas, credentialDefinitions, revocationStates = {}, }) {
        try {
            return await this.indy.proverCreateProof(this.wallet.handle, proofRequest, requestedCredentials, this.wallet.masterSecretId, schemas, credentialDefinitions, revocationStates);
        }
        catch (error) {
            throw new error_1.IndySdkError(error);
        }
    }
    /**
     * Store a credential in the wallet.
     *
     * @returns The credential id
     */
    async storeCredential({ credentialRequestMetadata, credential, credentialDefinition, credentialId, revocationRegistryDefinitions, }) {
        try {
            return await this.indy.proverStoreCredential(this.wallet.handle, credentialId !== null && credentialId !== void 0 ? credentialId : null, credentialRequestMetadata, credential, credentialDefinition, revocationRegistryDefinitions !== null && revocationRegistryDefinitions !== void 0 ? revocationRegistryDefinitions : null);
        }
        catch (error) {
            throw new error_1.IndySdkError(error);
        }
    }
    /**
     * Get a credential stored in the wallet by id.
     *
     * @param credentialId the id (referent) of the credential
     * @throws {Error} if the credential is not found
     * @returns the credential
     *
     * @todo handle record not found
     */
    async getCredential(credentialId) {
        try {
            return await this.indy.proverGetCredential(this.wallet.handle, credentialId);
        }
        catch (error) {
            throw new error_1.IndySdkError(error);
        }
    }
    /**
     * Create a credential request for the given credential offer.
     *
     * @returns The credential request and the credential request metadata
     */
    async createCredentialRequest({ holderDid, credentialOffer, credentialDefinition, }) {
        try {
            return await this.indy.proverCreateCredentialReq(this.wallet.handle, holderDid, credentialOffer, credentialDefinition, this.wallet.masterSecretId);
        }
        catch (error) {
            throw new error_1.IndySdkError(error);
        }
    }
    /**
     * Retrieve the credentials that are available for an attribute referent in the proof request.
     *
     * @param proofRequest The proof request to retrieve the credentials for
     * @param attributeReferent An attribute referent from the proof request to retrieve the credentials for
     * @param start Starting index
     * @param limit Maximum number of records to return
     *
     * @returns List of credentials that are available for building a proof for the given proof request
     *
     */
    async getCredentialsForProofRequest({ proofRequest, attributeReferent, start = 0, limit = 256, extraQuery, }) {
        try {
            // Open indy credential search
            const searchHandle = await this.indy.proverSearchCredentialsForProofReq(this.wallet.handle, proofRequest, extraQuery !== null && extraQuery !== void 0 ? extraQuery : null);
            try {
                // Make sure database cursors start at 'start' (bit ugly, but no way around in indy)
                if (start > 0) {
                    await this.fetchCredentialsForReferent(searchHandle, attributeReferent, start);
                }
                // Fetch the credentials
                const credentials = await this.fetchCredentialsForReferent(searchHandle, attributeReferent, limit);
                // TODO: sort the credentials (irrevocable first)
                return credentials;
            }
            finally {
                // Always close search
                await this.indy.proverCloseCredentialsSearchForProofReq(searchHandle);
            }
        }
        catch (error) {
            if (indyError_1.isIndyError(error)) {
                throw new error_1.IndySdkError(error);
            }
            throw error;
        }
    }
    async fetchCredentialsForReferent(searchHandle, referent, limit) {
        try {
            let credentials = [];
            // Allow max of 256 per fetch operation
            const chunk = limit ? Math.min(256, limit) : 256;
            // Loop while limit not reached (or no limit specified)
            while (!limit || credentials.length < limit) {
                // Retrieve credentials
                const credentialsJson = await this.indy.proverFetchCredentialsForProofReq(searchHandle, referent, chunk);
                credentials = [...credentials, ...credentialsJson];
                // If the number of credentials returned is less than chunk
                // It means we reached the end of the iterator (no more credentials)
                if (credentialsJson.length < chunk) {
                    return credentials;
                }
            }
            return credentials;
        }
        catch (error) {
            throw new error_1.IndySdkError(error);
        }
    }
};
IndyHolderService = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __metadata("design:paramtypes", [AgentConfig_1.AgentConfig, IndyWallet_1.IndyWallet])
], IndyHolderService);
exports.IndyHolderService = IndyHolderService;
//# sourceMappingURL=IndyHolderService.js.map
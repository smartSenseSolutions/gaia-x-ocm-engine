import type { ConnectionRecord } from './repository/ConnectionRecord';
import { AgentConfig } from '../../agent/AgentConfig';
import { Dispatcher } from '../../agent/Dispatcher';
import { MessageSender } from '../../agent/MessageSender';
import { MediationRecipientService } from '../routing/services/MediationRecipientService';
import { ConnectionInvitationMessage } from './messages';
import { ConnectionService } from './services/ConnectionService';
import { TrustPingService } from './services/TrustPingService';
export declare class ConnectionsModule {
    private agentConfig;
    private connectionService;
    private messageSender;
    private trustPingService;
    private mediationRecipientService;
    constructor(dispatcher: Dispatcher, agentConfig: AgentConfig, connectionService: ConnectionService, trustPingService: TrustPingService, mediationRecipientService: MediationRecipientService, messageSender: MessageSender);
    createConnection(config?: {
        autoAcceptConnection?: boolean;
        alias?: string;
        mediatorId?: string;
        multiUseInvitation?: boolean;
        myLabel?: string;
        myImageUrl?: string;
    }): Promise<{
        invitation: ConnectionInvitationMessage;
        connectionRecord: ConnectionRecord;
    }>;
    /**
     * Receive connection invitation as invitee and create connection. If auto accepting is enabled
     * via either the config passed in the function or the global agent config, a connection
     * request message will be send.
     *
     * @param invitationJson json object containing the invitation to receive
     * @param config config for handling of invitation
     * @returns new connection record
     */
    receiveInvitation(invitation: ConnectionInvitationMessage, config?: {
        autoAcceptConnection?: boolean;
        alias?: string;
        mediatorId?: string;
    }): Promise<ConnectionRecord>;
    /**
     * Receive connection invitation as invitee encoded as url and create connection. If auto accepting is enabled
     * via either the config passed in the function or the global agent config, a connection
     * request message will be send.
     *
     * @param invitationUrl url containing a base64 encoded invitation to receive
     * @param config config for handling of invitation
     * @returns new connection record
     */
    receiveInvitationFromUrl(invitationUrl: string, config?: {
        autoAcceptConnection?: boolean;
        alias?: string;
        mediatorId?: string;
    }): Promise<ConnectionRecord>;
    /**
     * Accept a connection invitation as invitee (by sending a connection request message) for the connection with the specified connection id.
     * This is not needed when auto accepting of connections is enabled.
     *
     * @param connectionId the id of the connection for which to accept the invitation
     * @returns connection record
     */
    acceptInvitation(connectionId: string): Promise<ConnectionRecord>;
    /**
     * Accept a connection request as inviter (by sending a connection response message) for the connection with the specified connection id.
     * This is not needed when auto accepting of connection is enabled.
     *
     * @param connectionId the id of the connection for which to accept the request
     * @returns connection record
     */
    acceptRequest(connectionId: string): Promise<ConnectionRecord>;
    /**
     * Accept a connection response as invitee (by sending a trust ping message) for the connection with the specified connection id.
     * This is not needed when auto accepting of connection is enabled.
     *
     * @param connectionId the id of the connection for which to accept the response
     * @returns connection record
     */
    acceptResponse(connectionId: string): Promise<ConnectionRecord>;
    returnWhenIsConnected(connectionId: string): Promise<ConnectionRecord>;
    /**
     * Retrieve all connections records
     *
     * @returns List containing all connection records
     */
    getAll(): Promise<ConnectionRecord[]>;
    /**
     * Retrieve a connection record by id
     *
     * @param connectionId The connection record id
     * @throws {RecordNotFoundError} If no record is found
     * @return The connection record
     *
     */
    getById(connectionId: string): Promise<ConnectionRecord>;
    /**
     * Find a connection record by id
     *
     * @param connectionId the connection record id
     * @returns The connection record or null if not found
     */
    findById(connectionId: string): Promise<ConnectionRecord | null>;
    /**
     * Delete a connection record by id
     *
     * @param connectionId the connection record id
     */
    deleteById(connectionId: string): Promise<void>;
    /**
     * Find connection by verkey.
     *
     * @param verkey the verkey to search for
     * @returns the connection record, or null if not found
     * @throws {RecordDuplicateError} if multiple connections are found for the given verkey
     */
    findByVerkey(verkey: string): Promise<ConnectionRecord | null>;
    /**
     * Find connection by their verkey.
     *
     * @param verkey the verkey to search for
     * @returns the connection record, or null if not found
     * @throws {RecordDuplicateError} if multiple connections are found for the given verkey
     */
    findByTheirKey(verkey: string): Promise<ConnectionRecord | null>;
    /**
     * Find connection by Invitation key.
     *
     * @param key the invitation key to search for
     * @returns the connection record, or null if not found
     * @throws {RecordDuplicateError} if multiple connections are found for the given verkey
     */
    findByInvitationKey(key: string): Promise<ConnectionRecord | null>;
    /**
     * Retrieve a connection record by thread id
     *
     * @param threadId The thread id
     * @throws {RecordNotFoundError} If no record is found
     * @throws {RecordDuplicateError} If multiple records are found
     * @returns The connection record
     */
    getByThreadId(threadId: string): Promise<ConnectionRecord>;
    private registerHandlers;
}

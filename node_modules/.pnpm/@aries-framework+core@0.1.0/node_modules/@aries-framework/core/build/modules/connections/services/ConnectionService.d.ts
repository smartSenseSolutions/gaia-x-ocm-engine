import type { AgentMessage } from '../../../agent/AgentMessage';
import type { InboundMessageContext } from '../../../agent/models/InboundMessageContext';
import type { AckMessage } from '../../common';
import type { ConnectionProblemReportMessage } from '../messages';
import { AgentConfig } from '../../../agent/AgentConfig';
import { EventEmitter } from '../../../agent/EventEmitter';
import { Wallet } from '../../../wallet/Wallet';
import { ConnectionInvitationMessage, ConnectionRequestMessage, ConnectionResponseMessage, TrustPingMessage } from '../messages';
import { ConnectionState } from '../models';
import { ConnectionRecord } from '../repository/ConnectionRecord';
import { ConnectionRepository } from '../repository/ConnectionRepository';
export declare class ConnectionService {
    private wallet;
    private config;
    private connectionRepository;
    private eventEmitter;
    private logger;
    constructor(wallet: Wallet, config: AgentConfig, connectionRepository: ConnectionRepository, eventEmitter: EventEmitter);
    /**
     * Create a new connection record containing a connection invitation message
     *
     * @param config config for creation of connection and invitation
     * @returns new connection record
     */
    createInvitation(config: {
        routing: Routing;
        autoAcceptConnection?: boolean;
        alias?: string;
        multiUseInvitation?: boolean;
        myLabel?: string;
        myImageUrl?: string;
    }): Promise<ConnectionProtocolMsgReturnType<ConnectionInvitationMessage>>;
    /**
     * Process a received invitation message. This will not accept the invitation
     * or send an invitation request message. It will only create a connection record
     * with all the information about the invitation stored. Use {@link ConnectionService.createRequest}
     * after calling this function to create a connection request.
     *
     * @param invitation the invitation message to process
     * @returns new connection record.
     */
    processInvitation(invitation: ConnectionInvitationMessage, config: {
        routing: Routing;
        autoAcceptConnection?: boolean;
        alias?: string;
    }): Promise<ConnectionRecord>;
    /**
     * Create a connection request message for the connection with the specified connection id.
     *
     * @param connectionId the id of the connection for which to create a connection request
     * @param config config for creation of connection request
     * @returns outbound message containing connection request
     */
    createRequest(connectionId: string, config?: {
        myLabel?: string;
        myImageUrl?: string;
    }): Promise<ConnectionProtocolMsgReturnType<ConnectionRequestMessage>>;
    /**
     * Process a received connection request message. This will not accept the connection request
     * or send a connection response message. It will only update the existing connection record
     * with all the new information from the connection request message. Use {@link ConnectionService.createResponse}
     * after calling this function to create a connection response.
     *
     * @param messageContext the message context containing a connection request message
     * @returns updated connection record
     */
    processRequest(messageContext: InboundMessageContext<ConnectionRequestMessage>, routing?: Routing): Promise<ConnectionRecord>;
    /**
     * Create a connection response message for the connection with the specified connection id.
     *
     * @param connectionId the id of the connection for which to create a connection response
     * @returns outbound message containing connection response
     */
    createResponse(connectionId: string): Promise<ConnectionProtocolMsgReturnType<ConnectionResponseMessage>>;
    /**
     * Process a received connection response message. This will not accept the connection request
     * or send a connection acknowledgement message. It will only update the existing connection record
     * with all the new information from the connection response message. Use {@link ConnectionService.createTrustPing}
     * after calling this function to create a trust ping message.
     *
     * @param messageContext the message context containing a connection response message
     * @returns updated connection record
     */
    processResponse(messageContext: InboundMessageContext<ConnectionResponseMessage>): Promise<ConnectionRecord>;
    /**
     * Create a trust ping message for the connection with the specified connection id.
     *
     * By default a trust ping message should elicit a response. If this is not desired the
     * `config.responseRequested` property can be set to `false`.
     *
     * @param connectionId the id of the connection for which to create a trust ping message
     * @param config the config for the trust ping message
     * @returns outbound message containing trust ping message
     */
    createTrustPing(connectionId: string, config?: {
        responseRequested?: boolean;
        comment?: string;
    }): Promise<ConnectionProtocolMsgReturnType<TrustPingMessage>>;
    /**
     * Process a received ack message. This will update the state of the connection
     * to Completed if this is not already the case.
     *
     * @param messageContext the message context containing an ack message
     * @returns updated connection record
     */
    processAck(messageContext: InboundMessageContext<AckMessage>): Promise<ConnectionRecord>;
    /**
     * Process a received {@link ProblemReportMessage}.
     *
     * @param messageContext The message context containing a connection problem report message
     * @returns connection record associated with the connection problem report message
     *
     */
    processProblemReport(messageContext: InboundMessageContext<ConnectionProblemReportMessage>): Promise<ConnectionRecord>;
    /**
     * Assert that an inbound message either has a connection associated with it,
     * or has everything correctly set up for connection-less exchange.
     *
     * @param messageContext - the inbound message context
     * @param previousRespondence - previous sent and received message to determine if a valid service decorator is present
     */
    assertConnectionOrServiceDecorator(messageContext: InboundMessageContext, { previousSentMessage, previousReceivedMessage, }?: {
        previousSentMessage?: AgentMessage;
        previousReceivedMessage?: AgentMessage;
    }): void;
    updateState(connectionRecord: ConnectionRecord, newState: ConnectionState): Promise<void>;
    update(connectionRecord: ConnectionRecord): Promise<void>;
    /**
     * Retrieve all connections records
     *
     * @returns List containing all connection records
     */
    getAll(): Promise<ConnectionRecord[]>;
    /**
     * Retrieve a connection record by id
     *
     * @param connectionId The connection record id
     * @throws {RecordNotFoundError} If no record is found
     * @return The connection record
     *
     */
    getById(connectionId: string): Promise<ConnectionRecord>;
    /**
     * Find a connection record by id
     *
     * @param connectionId the connection record id
     * @returns The connection record or null if not found
     */
    findById(connectionId: string): Promise<ConnectionRecord | null>;
    /**
     * Delete a connection record by id
     *
     * @param connectionId the connection record id
     */
    deleteById(connectionId: string): Promise<void>;
    /**
     * Find connection by verkey.
     *
     * @param verkey the verkey to search for
     * @returns the connection record, or null if not found
     * @throws {RecordDuplicateError} if multiple connections are found for the given verkey
     */
    findByVerkey(verkey: string): Promise<ConnectionRecord | null>;
    /**
     * Find connection by their verkey.
     *
     * @param verkey the verkey to search for
     * @returns the connection record, or null if not found
     * @throws {RecordDuplicateError} if multiple connections are found for the given verkey
     */
    findByTheirKey(verkey: string): Promise<ConnectionRecord | null>;
    /**
     * Find connection by invitation key.
     *
     * @param key the invitation key to search for
     * @returns the connection record, or null if not found
     * @throws {RecordDuplicateError} if multiple connections are found for the given verkey
     */
    findByInvitationKey(key: string): Promise<ConnectionRecord | null>;
    /**
     * Retrieve a connection record by thread id
     *
     * @param threadId The thread id
     * @throws {RecordNotFoundError} If no record is found
     * @throws {RecordDuplicateError} If multiple records are found
     * @returns The connection record
     */
    getByThreadId(threadId: string): Promise<ConnectionRecord>;
    private createConnection;
    returnWhenIsConnected(connectionId: string, timeoutMs?: number): Promise<ConnectionRecord>;
}
export interface Routing {
    endpoints: string[];
    verkey: string;
    did: string;
    routingKeys: string[];
    mediatorId?: string;
}
export interface ConnectionProtocolMsgReturnType<MessageType extends AgentMessage> {
    message: MessageType;
    connectionRecord: ConnectionRecord;
}

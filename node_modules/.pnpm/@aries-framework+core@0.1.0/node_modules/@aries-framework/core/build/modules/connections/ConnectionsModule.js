"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionsModule = void 0;
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../agent/AgentConfig");
const Dispatcher_1 = require("../../agent/Dispatcher");
const MessageSender_1 = require("../../agent/MessageSender");
const helpers_1 = require("../../agent/helpers");
const MediationRecipientService_1 = require("../routing/services/MediationRecipientService");
const handlers_1 = require("./handlers");
const messages_1 = require("./messages");
const ConnectionService_1 = require("./services/ConnectionService");
const TrustPingService_1 = require("./services/TrustPingService");
let ConnectionsModule = class ConnectionsModule {
    constructor(dispatcher, agentConfig, connectionService, trustPingService, mediationRecipientService, messageSender) {
        this.agentConfig = agentConfig;
        this.connectionService = connectionService;
        this.trustPingService = trustPingService;
        this.mediationRecipientService = mediationRecipientService;
        this.messageSender = messageSender;
        this.registerHandlers(dispatcher);
    }
    async createConnection(config) {
        const myRouting = await this.mediationRecipientService.getRouting({
            mediatorId: config === null || config === void 0 ? void 0 : config.mediatorId,
            useDefaultMediator: true,
        });
        const { connectionRecord: connectionRecord, message: invitation } = await this.connectionService.createInvitation({
            autoAcceptConnection: config === null || config === void 0 ? void 0 : config.autoAcceptConnection,
            alias: config === null || config === void 0 ? void 0 : config.alias,
            routing: myRouting,
            multiUseInvitation: config === null || config === void 0 ? void 0 : config.multiUseInvitation,
            myLabel: config === null || config === void 0 ? void 0 : config.myLabel,
            myImageUrl: config === null || config === void 0 ? void 0 : config.myImageUrl,
        });
        return { connectionRecord, invitation };
    }
    /**
     * Receive connection invitation as invitee and create connection. If auto accepting is enabled
     * via either the config passed in the function or the global agent config, a connection
     * request message will be send.
     *
     * @param invitationJson json object containing the invitation to receive
     * @param config config for handling of invitation
     * @returns new connection record
     */
    async receiveInvitation(invitation, config) {
        var _a;
        const myRouting = await this.mediationRecipientService.getRouting({ mediatorId: config === null || config === void 0 ? void 0 : config.mediatorId });
        let connection = await this.connectionService.processInvitation(invitation, {
            autoAcceptConnection: config === null || config === void 0 ? void 0 : config.autoAcceptConnection,
            alias: config === null || config === void 0 ? void 0 : config.alias,
            routing: myRouting,
        });
        // if auto accept is enabled (either on the record or the global agent config)
        // we directly send a connection request
        if ((_a = connection.autoAcceptConnection) !== null && _a !== void 0 ? _a : this.agentConfig.autoAcceptConnections) {
            connection = await this.acceptInvitation(connection.id);
        }
        return connection;
    }
    /**
     * Receive connection invitation as invitee encoded as url and create connection. If auto accepting is enabled
     * via either the config passed in the function or the global agent config, a connection
     * request message will be send.
     *
     * @param invitationUrl url containing a base64 encoded invitation to receive
     * @param config config for handling of invitation
     * @returns new connection record
     */
    async receiveInvitationFromUrl(invitationUrl, config) {
        const invitation = await messages_1.ConnectionInvitationMessage.fromUrl(invitationUrl);
        return this.receiveInvitation(invitation, config);
    }
    /**
     * Accept a connection invitation as invitee (by sending a connection request message) for the connection with the specified connection id.
     * This is not needed when auto accepting of connections is enabled.
     *
     * @param connectionId the id of the connection for which to accept the invitation
     * @returns connection record
     */
    async acceptInvitation(connectionId) {
        const { message, connectionRecord: connectionRecord } = await this.connectionService.createRequest(connectionId);
        const outbound = helpers_1.createOutboundMessage(connectionRecord, message);
        await this.messageSender.sendMessage(outbound);
        return connectionRecord;
    }
    /**
     * Accept a connection request as inviter (by sending a connection response message) for the connection with the specified connection id.
     * This is not needed when auto accepting of connection is enabled.
     *
     * @param connectionId the id of the connection for which to accept the request
     * @returns connection record
     */
    async acceptRequest(connectionId) {
        const { message, connectionRecord: connectionRecord } = await this.connectionService.createResponse(connectionId);
        const outbound = helpers_1.createOutboundMessage(connectionRecord, message);
        await this.messageSender.sendMessage(outbound);
        return connectionRecord;
    }
    /**
     * Accept a connection response as invitee (by sending a trust ping message) for the connection with the specified connection id.
     * This is not needed when auto accepting of connection is enabled.
     *
     * @param connectionId the id of the connection for which to accept the response
     * @returns connection record
     */
    async acceptResponse(connectionId) {
        const { message, connectionRecord: connectionRecord } = await this.connectionService.createTrustPing(connectionId, {
            responseRequested: false,
        });
        const outbound = helpers_1.createOutboundMessage(connectionRecord, message);
        await this.messageSender.sendMessage(outbound);
        return connectionRecord;
    }
    async returnWhenIsConnected(connectionId) {
        return this.connectionService.returnWhenIsConnected(connectionId);
    }
    /**
     * Retrieve all connections records
     *
     * @returns List containing all connection records
     */
    getAll() {
        return this.connectionService.getAll();
    }
    /**
     * Retrieve a connection record by id
     *
     * @param connectionId The connection record id
     * @throws {RecordNotFoundError} If no record is found
     * @return The connection record
     *
     */
    getById(connectionId) {
        return this.connectionService.getById(connectionId);
    }
    /**
     * Find a connection record by id
     *
     * @param connectionId the connection record id
     * @returns The connection record or null if not found
     */
    findById(connectionId) {
        return this.connectionService.findById(connectionId);
    }
    /**
     * Delete a connection record by id
     *
     * @param connectionId the connection record id
     */
    async deleteById(connectionId) {
        return this.connectionService.deleteById(connectionId);
    }
    /**
     * Find connection by verkey.
     *
     * @param verkey the verkey to search for
     * @returns the connection record, or null if not found
     * @throws {RecordDuplicateError} if multiple connections are found for the given verkey
     */
    findByVerkey(verkey) {
        return this.connectionService.findByVerkey(verkey);
    }
    /**
     * Find connection by their verkey.
     *
     * @param verkey the verkey to search for
     * @returns the connection record, or null if not found
     * @throws {RecordDuplicateError} if multiple connections are found for the given verkey
     */
    findByTheirKey(verkey) {
        return this.connectionService.findByTheirKey(verkey);
    }
    /**
     * Find connection by Invitation key.
     *
     * @param key the invitation key to search for
     * @returns the connection record, or null if not found
     * @throws {RecordDuplicateError} if multiple connections are found for the given verkey
     */
    findByInvitationKey(key) {
        return this.connectionService.findByInvitationKey(key);
    }
    /**
     * Retrieve a connection record by thread id
     *
     * @param threadId The thread id
     * @throws {RecordNotFoundError} If no record is found
     * @throws {RecordDuplicateError} If multiple records are found
     * @returns The connection record
     */
    getByThreadId(threadId) {
        return this.connectionService.getByThreadId(threadId);
    }
    registerHandlers(dispatcher) {
        dispatcher.registerHandler(new handlers_1.ConnectionRequestHandler(this.connectionService, this.agentConfig, this.mediationRecipientService));
        dispatcher.registerHandler(new handlers_1.ConnectionResponseHandler(this.connectionService, this.agentConfig));
        dispatcher.registerHandler(new handlers_1.AckMessageHandler(this.connectionService));
        dispatcher.registerHandler(new handlers_1.TrustPingMessageHandler(this.trustPingService, this.connectionService));
        dispatcher.registerHandler(new handlers_1.TrustPingResponseMessageHandler(this.trustPingService));
    }
};
ConnectionsModule = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __metadata("design:paramtypes", [Dispatcher_1.Dispatcher,
        AgentConfig_1.AgentConfig,
        ConnectionService_1.ConnectionService,
        TrustPingService_1.TrustPingService,
        MediationRecipientService_1.MediationRecipientService,
        MessageSender_1.MessageSender])
], ConnectionsModule);
exports.ConnectionsModule = ConnectionsModule;
//# sourceMappingURL=ConnectionsModule.js.map
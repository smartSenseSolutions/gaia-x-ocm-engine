"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediatorService = void 0;
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../../agent/AgentConfig");
const EventEmitter_1 = require("../../../agent/EventEmitter");
const constants_1 = require("../../../constants");
const error_1 = require("../../../error");
const RoutingEvents_1 = require("../RoutingEvents");
const messages_1 = require("../messages");
const MediationRole_1 = require("../models/MediationRole");
const MediationState_1 = require("../models/MediationState");
const repository_1 = require("../repository");
const MediationRecord_1 = require("../repository/MediationRecord");
const MediationRepository_1 = require("../repository/MediationRepository");
const MediatorRoutingRepository_1 = require("../repository/MediatorRoutingRepository");
let MediatorService = class MediatorService {
    constructor(mediationRepository, mediatorRoutingRepository, agentConfig, wallet, eventEmitter) {
        this.mediationRepository = mediationRepository;
        this.mediatorRoutingRepository = mediatorRoutingRepository;
        this.agentConfig = agentConfig;
        this.wallet = wallet;
        this.eventEmitter = eventEmitter;
    }
    async getRoutingKeys() {
        this.agentConfig.logger.debug('Retrieving mediator routing keys');
        // If the routing record is not loaded yet, retrieve it from storage
        if (!this._mediatorRoutingRecord) {
            this.agentConfig.logger.debug('Mediator routing record not loaded yet, retrieving from storage');
            let routingRecord = await this.mediatorRoutingRepository.findById(this.mediatorRoutingRepository.MEDIATOR_ROUTING_RECORD_ID);
            // If we don't have a routing record yet, create it
            if (!routingRecord) {
                this.agentConfig.logger.debug('Mediator routing record does not exist yet, creating routing keys and record');
                const { verkey } = await this.wallet.createDid();
                routingRecord = new repository_1.MediatorRoutingRecord({
                    id: this.mediatorRoutingRepository.MEDIATOR_ROUTING_RECORD_ID,
                    routingKeys: [verkey],
                });
                await this.mediatorRoutingRepository.save(routingRecord);
            }
            this._mediatorRoutingRecord = routingRecord;
        }
        // Return the routing keys
        this.agentConfig.logger.debug(`Returning mediator routing keys ${this._mediatorRoutingRecord.routingKeys}`);
        return this._mediatorRoutingRecord.routingKeys;
    }
    async processForwardMessage(messageContext) {
        const { message } = messageContext;
        // TODO: update to class-validator validation
        if (!message.to) {
            throw new error_1.AriesFrameworkError('Invalid Message: Missing required attribute "to"');
        }
        const mediationRecord = await this.mediationRepository.getSingleByRecipientKey(message.to);
        // Assert mediation record is ready to be used
        mediationRecord.assertReady();
        return {
            encryptedMessage: message.message,
            mediationRecord,
        };
    }
    async processKeylistUpdateRequest(messageContext) {
        // Assert Ready connection
        const connection = messageContext.assertReadyConnection();
        const { message } = messageContext;
        const keylist = [];
        const mediationRecord = await this.mediationRepository.getByConnectionId(connection.id);
        for (const update of message.updates) {
            const updated = new messages_1.KeylistUpdated({
                action: update.action,
                recipientKey: update.recipientKey,
                result: messages_1.KeylistUpdateResult.NoChange,
            });
            if (update.action === messages_1.KeylistUpdateAction.add) {
                updated.result = await this.saveRoute(update.recipientKey, mediationRecord);
                keylist.push(updated);
            }
            else if (update.action === messages_1.KeylistUpdateAction.remove) {
                updated.result = await this.removeRoute(update.recipientKey, mediationRecord);
                keylist.push(updated);
            }
        }
        return new messages_1.KeylistUpdateResponseMessage({ keylist, threadId: message.threadId });
    }
    async saveRoute(recipientKey, mediationRecord) {
        try {
            mediationRecord.recipientKeys.push(recipientKey);
            this.mediationRepository.update(mediationRecord);
            return messages_1.KeylistUpdateResult.Success;
        }
        catch (error) {
            this.agentConfig.logger.error(`Error processing keylist update action for verkey '${recipientKey}' and mediation record '${mediationRecord.id}'`);
            return messages_1.KeylistUpdateResult.ServerError;
        }
    }
    async removeRoute(recipientKey, mediationRecord) {
        try {
            const index = mediationRecord.recipientKeys.indexOf(recipientKey, 0);
            if (index > -1) {
                mediationRecord.recipientKeys.splice(index, 1);
                await this.mediationRepository.update(mediationRecord);
                return messages_1.KeylistUpdateResult.Success;
            }
            return messages_1.KeylistUpdateResult.ServerError;
        }
        catch (error) {
            this.agentConfig.logger.error(`Error processing keylist remove action for verkey '${recipientKey}' and mediation record '${mediationRecord.id}'`);
            return messages_1.KeylistUpdateResult.ServerError;
        }
    }
    async createGrantMediationMessage(mediationRecord) {
        // Assert
        mediationRecord.assertState(MediationState_1.MediationState.Requested);
        mediationRecord.assertRole(MediationRole_1.MediationRole.Mediator);
        mediationRecord.state = MediationState_1.MediationState.Granted;
        await this.mediationRepository.update(mediationRecord);
        const message = new messages_1.MediationGrantMessage({
            endpoint: this.agentConfig.endpoints[0],
            routingKeys: await this.getRoutingKeys(),
            threadId: mediationRecord.threadId,
        });
        return { mediationRecord, message };
    }
    async processMediationRequest(messageContext) {
        // Assert ready connection
        const connection = messageContext.assertReadyConnection();
        const mediationRecord = new MediationRecord_1.MediationRecord({
            connectionId: connection.id,
            role: MediationRole_1.MediationRole.Mediator,
            state: MediationState_1.MediationState.Requested,
            threadId: messageContext.message.threadId,
        });
        await this.mediationRepository.save(mediationRecord);
        this.eventEmitter.emit({
            type: RoutingEvents_1.RoutingEventTypes.MediationStateChanged,
            payload: {
                mediationRecord,
                previousState: null,
            },
        });
        return mediationRecord;
    }
    async findById(mediatorRecordId) {
        return this.mediationRepository.findById(mediatorRecordId);
    }
    async getById(mediatorRecordId) {
        return this.mediationRepository.getById(mediatorRecordId);
    }
    async getAll() {
        return await this.mediationRepository.getAll();
    }
    async updateState(mediationRecord, newState) {
        const previousState = mediationRecord.state;
        mediationRecord.state = newState;
        await this.mediationRepository.update(mediationRecord);
        this.eventEmitter.emit({
            type: RoutingEvents_1.RoutingEventTypes.MediationStateChanged,
            payload: {
                mediationRecord,
                previousState: previousState,
            },
        });
    }
};
MediatorService = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __param(3, tsyringe_1.inject(constants_1.InjectionSymbols.Wallet)),
    __metadata("design:paramtypes", [MediationRepository_1.MediationRepository,
        MediatorRoutingRepository_1.MediatorRoutingRepository,
        AgentConfig_1.AgentConfig, Object, EventEmitter_1.EventEmitter])
], MediatorService);
exports.MediatorService = MediatorService;
//# sourceMappingURL=MediatorService.js.map
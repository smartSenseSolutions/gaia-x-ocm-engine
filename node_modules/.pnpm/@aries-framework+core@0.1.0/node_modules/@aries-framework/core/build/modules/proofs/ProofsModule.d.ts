import type { AutoAcceptProof } from './ProofAutoAcceptType';
import type { PresentationPreview, RequestPresentationMessage } from './messages';
import type { RequestedCredentials, RetrievedCredentials } from './models';
import type { ProofRequestOptions } from './models/ProofRequest';
import type { ProofRecord } from './repository/ProofRecord';
import { AgentConfig } from '../../agent/AgentConfig';
import { Dispatcher } from '../../agent/Dispatcher';
import { MessageSender } from '../../agent/MessageSender';
import { ConnectionService } from '../connections/services/ConnectionService';
import { MediationRecipientService } from '../routing/services/MediationRecipientService';
import { ProofResponseCoordinator } from './ProofResponseCoordinator';
import { ProofService } from './services';
export declare class ProofsModule {
    private proofService;
    private connectionService;
    private messageSender;
    private mediationRecipientService;
    private agentConfig;
    private proofResponseCoordinator;
    constructor(dispatcher: Dispatcher, proofService: ProofService, connectionService: ConnectionService, mediationRecipientService: MediationRecipientService, agentConfig: AgentConfig, messageSender: MessageSender, proofResponseCoordinator: ProofResponseCoordinator);
    /**
     * Initiate a new presentation exchange as prover by sending a presentation proposal message
     * to the connection with the specified connection id.
     *
     * @param connectionId The connection to send the proof proposal to
     * @param presentationProposal The presentation proposal to include in the message
     * @param config Additional configuration to use for the proposal
     * @returns Proof record associated with the sent proposal message
     *
     */
    proposeProof(connectionId: string, presentationProposal: PresentationPreview, config?: {
        comment?: string;
        autoAcceptProof?: AutoAcceptProof;
    }): Promise<ProofRecord>;
    /**
     * Accept a presentation proposal as verifier (by sending a presentation request message) to the connection
     * associated with the proof record.
     *
     * @param proofRecordId The id of the proof record for which to accept the proposal
     * @param config Additional configuration to use for the request
     * @returns Proof record associated with the presentation request
     *
     */
    acceptProposal(proofRecordId: string, config?: {
        request?: {
            name?: string;
            version?: string;
            nonce?: string;
        };
        comment?: string;
    }): Promise<ProofRecord>;
    /**
     * Initiate a new presentation exchange as verifier by sending a presentation request message
     * to the connection with the specified connection id
     *
     * @param connectionId The connection to send the proof request to
     * @param proofRequestOptions Options to build the proof request
     * @returns Proof record associated with the sent request message
     *
     */
    requestProof(connectionId: string, proofRequestOptions: CreateProofRequestOptions, config?: ProofRequestConfig): Promise<ProofRecord>;
    /**
     * Initiate a new presentation exchange as verifier by creating a presentation request
     * not bound to any connection. The request must be delivered out-of-band to the holder
     *
     * @param proofRequestOptions Options to build the proof request
     * @returns The proof record and proof request message
     *
     */
    createOutOfBandRequest(proofRequestOptions: CreateProofRequestOptions, config?: ProofRequestConfig): Promise<{
        requestMessage: RequestPresentationMessage;
        proofRecord: ProofRecord;
    }>;
    /**
     * Accept a presentation request as prover (by sending a presentation message) to the connection
     * associated with the proof record.
     *
     * @param proofRecordId The id of the proof record for which to accept the request
     * @param requestedCredentials The requested credentials object specifying which credentials to use for the proof
     * @param config Additional configuration to use for the presentation
     * @returns Proof record associated with the sent presentation message
     *
     */
    acceptRequest(proofRecordId: string, requestedCredentials: RequestedCredentials, config?: {
        comment?: string;
    }): Promise<ProofRecord>;
    /**
     * Declines a proof request as holder
     * @param proofRecordId the id of the proof request to be declined
     * @returns proof record that was declined
     */
    declineRequest(proofRecordId: string): Promise<ProofRecord>;
    /**
     * Accept a presentation as prover (by sending a presentation acknowledgement message) to the connection
     * associated with the proof record.
     *
     * @param proofRecordId The id of the proof record for which to accept the presentation
     * @returns Proof record associated with the sent presentation acknowledgement message
     *
     */
    acceptPresentation(proofRecordId: string): Promise<ProofRecord>;
    /**
     * Create a {@link RetrievedCredentials} object. Given input proof request and presentation proposal,
     * use credentials in the wallet to build indy requested credentials object for input to proof creation.
     * If restrictions allow, self attested attributes will be used.
     *
     *
     * @param proofRecordId the id of the proof request to get the matching credentials for
     * @param config optional configuration for credential selection process. Use `filterByPresentationPreview` (default `true`) to only include
     *  credentials that match the presentation preview from the presentation proposal (if available).
  
     * @returns RetrievedCredentials object
     */
    getRequestedCredentialsForProofRequest(proofRecordId: string, config?: GetRequestedCredentialsConfig): Promise<RetrievedCredentials>;
    /**
     * Takes a RetrievedCredentials object and auto selects credentials in a RequestedCredentials object
     *
     * Use the return value of this method as input to {@link ProofService.createPresentation} to
     * automatically accept a received presentation request.
     *
     * @param retrievedCredentials The retrieved credentials object to get credentials from
     *
     * @returns RequestedCredentials
     */
    autoSelectCredentialsForProofRequest(retrievedCredentials: RetrievedCredentials): RequestedCredentials;
    /**
     * Send problem report message for a proof record
     * @param proofRecordId  The id of the proof record for which to send problem report
     * @param message message to send
     * @returns proof record associated with the proof problem report message
     */
    sendProblemReport(proofRecordId: string, message: string): Promise<ProofRecord>;
    /**
     * Retrieve all proof records
     *
     * @returns List containing all proof records
     */
    getAll(): Promise<ProofRecord[]>;
    /**
     * Retrieve a proof record by id
     *
     * @param proofRecordId The proof record id
     * @throws {RecordNotFoundError} If no record is found
     * @throws {RecordDuplicateError} If multiple records are found
     * @return The proof record
     *
     */
    getById(proofRecordId: string): Promise<ProofRecord>;
    /**
     * Retrieve a proof record by id
     *
     * @param proofRecordId The proof record id
     * @return The proof record or null if not found
     *
     */
    findById(proofRecordId: string): Promise<ProofRecord | null>;
    /**
     * Delete a proof record by id
     *
     * @param proofId the proof record id
     */
    deleteById(proofId: string): Promise<void>;
    private registerHandlers;
}
export declare type CreateProofRequestOptions = Partial<Pick<ProofRequestOptions, 'name' | 'nonce' | 'requestedAttributes' | 'requestedPredicates'>>;
export interface ProofRequestConfig {
    comment?: string;
    autoAcceptProof?: AutoAcceptProof;
}
export interface GetRequestedCredentialsConfig {
    /**
     * Whether to filter the retrieved credentials using the presentation preview.
     * This configuration will only have effect if a presentation proposal message is available
     * containing a presentation preview.
     */
    filterByPresentationPreview?: boolean;
}

"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProofService = void 0;
const class_validator_1 = require("class-validator");
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../../agent/AgentConfig");
const EventEmitter_1 = require("../../../agent/EventEmitter");
const constants_1 = require("../../../constants");
const Attachment_1 = require("../../../decorators/attachment/Attachment");
const error_1 = require("../../../error");
const JsonEncoder_1 = require("../../../utils/JsonEncoder");
const JsonTransformer_1 = require("../../../utils/JsonTransformer");
const uuid_1 = require("../../../utils/uuid");
const common_1 = require("../../common");
const connections_1 = require("../../connections");
const credentials_1 = require("../../credentials");
const indy_1 = require("../../indy");
const IndyLedgerService_1 = require("../../ledger/services/IndyLedgerService");
const ProofEvents_1 = require("../ProofEvents");
const ProofState_1 = require("../ProofState");
const errors_1 = require("../errors");
const messages_1 = require("../messages");
const models_1 = require("../models");
const repository_1 = require("../repository");
const ProofRecord_1 = require("../repository/ProofRecord");
/**
 * @todo add method to check if request matches proposal. Useful to see if a request I received is the same as the proposal I sent.
 * @todo add method to reject / revoke messages
 * @todo validate attachments / messages
 */
let ProofService = class ProofService {
    constructor(proofRepository, ledgerService, wallet, agentConfig, indyHolderService, indyVerifierService, connectionService, eventEmitter, credentialRepository) {
        this.proofRepository = proofRepository;
        this.credentialRepository = credentialRepository;
        this.ledgerService = ledgerService;
        this.wallet = wallet;
        this.logger = agentConfig.logger;
        this.indyHolderService = indyHolderService;
        this.indyVerifierService = indyVerifierService;
        this.connectionService = connectionService;
        this.eventEmitter = eventEmitter;
    }
    /**
     * Create a {@link ProposePresentationMessage} not bound to an existing presentation exchange.
     * To create a proposal as response to an existing presentation exchange, use {@link ProofService.createProposalAsResponse}.
     *
     * @param connectionRecord The connection for which to create the presentation proposal
     * @param presentationProposal The presentation proposal to include in the message
     * @param config Additional configuration to use for the proposal
     * @returns Object containing proposal message and associated proof record
     *
     */
    async createProposal(connectionRecord, presentationProposal, config) {
        // Assert
        connectionRecord.assertReady();
        // Create message
        const proposalMessage = new messages_1.ProposePresentationMessage({
            comment: config === null || config === void 0 ? void 0 : config.comment,
            presentationProposal,
        });
        // Create record
        const proofRecord = new ProofRecord_1.ProofRecord({
            connectionId: connectionRecord.id,
            threadId: proposalMessage.threadId,
            state: ProofState_1.ProofState.ProposalSent,
            proposalMessage,
            autoAcceptProof: config === null || config === void 0 ? void 0 : config.autoAcceptProof,
        });
        await this.proofRepository.save(proofRecord);
        this.eventEmitter.emit({
            type: ProofEvents_1.ProofEventTypes.ProofStateChanged,
            payload: { proofRecord, previousState: null },
        });
        return { message: proposalMessage, proofRecord };
    }
    /**
     * Create a {@link ProposePresentationMessage} as response to a received presentation request.
     * To create a proposal not bound to an existing presentation exchange, use {@link ProofService.createProposal}.
     *
     * @param proofRecord The proof record for which to create the presentation proposal
     * @param presentationProposal The presentation proposal to include in the message
     * @param config Additional configuration to use for the proposal
     * @returns Object containing proposal message and associated proof record
     *
     */
    async createProposalAsResponse(proofRecord, presentationProposal, config) {
        // Assert
        proofRecord.assertState(ProofState_1.ProofState.RequestReceived);
        // Create message
        const proposalMessage = new messages_1.ProposePresentationMessage({
            comment: config === null || config === void 0 ? void 0 : config.comment,
            presentationProposal,
        });
        proposalMessage.setThread({ threadId: proofRecord.threadId });
        // Update record
        proofRecord.proposalMessage = proposalMessage;
        this.updateState(proofRecord, ProofState_1.ProofState.ProposalSent);
        return { message: proposalMessage, proofRecord };
    }
    /**
     * Decline a proof request
     * @param proofRecord The proof request to be declined
     */
    async declineRequest(proofRecord) {
        proofRecord.assertState(ProofState_1.ProofState.RequestReceived);
        await this.updateState(proofRecord, ProofState_1.ProofState.Declined);
        return proofRecord;
    }
    /**
     * Process a received {@link ProposePresentationMessage}. This will not accept the presentation proposal
     * or send a presentation request. It will only create a new, or update the existing proof record with
     * the information from the presentation proposal message. Use {@link ProofService.createRequestAsResponse}
     * after calling this method to create a presentation request.
     *
     * @param messageContext The message context containing a presentation proposal message
     * @returns proof record associated with the presentation proposal message
     *
     */
    async processProposal(messageContext) {
        let proofRecord;
        const { message: proposalMessage, connection } = messageContext;
        this.logger.debug(`Processing presentation proposal with id ${proposalMessage.id}`);
        try {
            // Proof record already exists
            proofRecord = await this.getByThreadAndConnectionId(proposalMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
            // Assert
            proofRecord.assertState(ProofState_1.ProofState.RequestSent);
            this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
                previousReceivedMessage: proofRecord.proposalMessage,
                previousSentMessage: proofRecord.requestMessage,
            });
            // Update record
            proofRecord.proposalMessage = proposalMessage;
            await this.updateState(proofRecord, ProofState_1.ProofState.ProposalReceived);
        }
        catch (_a) {
            // No proof record exists with thread id
            proofRecord = new ProofRecord_1.ProofRecord({
                connectionId: connection === null || connection === void 0 ? void 0 : connection.id,
                threadId: proposalMessage.threadId,
                proposalMessage,
                state: ProofState_1.ProofState.ProposalReceived,
            });
            // Assert
            this.connectionService.assertConnectionOrServiceDecorator(messageContext);
            // Save record
            await this.proofRepository.save(proofRecord);
            this.eventEmitter.emit({
                type: ProofEvents_1.ProofEventTypes.ProofStateChanged,
                payload: {
                    proofRecord,
                    previousState: null,
                },
            });
        }
        return proofRecord;
    }
    /**
     * Create a {@link RequestPresentationMessage} as response to a received presentation proposal.
     * To create a request not bound to an existing presentation exchange, use {@link ProofService.createRequest}.
     *
     * @param proofRecord The proof record for which to create the presentation request
     * @param proofRequest The proof request to include in the message
     * @param config Additional configuration to use for the request
     * @returns Object containing request message and associated proof record
     *
     */
    async createRequestAsResponse(proofRecord, proofRequest, config) {
        // Assert
        proofRecord.assertState(ProofState_1.ProofState.ProposalReceived);
        // Create message
        const attachment = new Attachment_1.Attachment({
            id: messages_1.INDY_PROOF_REQUEST_ATTACHMENT_ID,
            mimeType: 'application/json',
            data: new Attachment_1.AttachmentData({
                base64: JsonEncoder_1.JsonEncoder.toBase64(proofRequest),
            }),
        });
        const requestPresentationMessage = new messages_1.RequestPresentationMessage({
            comment: config === null || config === void 0 ? void 0 : config.comment,
            requestPresentationAttachments: [attachment],
        });
        requestPresentationMessage.setThread({
            threadId: proofRecord.threadId,
        });
        // Update record
        proofRecord.requestMessage = requestPresentationMessage;
        await this.updateState(proofRecord, ProofState_1.ProofState.RequestSent);
        return { message: requestPresentationMessage, proofRecord };
    }
    /**
     * Create a {@link RequestPresentationMessage} not bound to an existing presentation exchange.
     * To create a request as response to an existing presentation exchange, use {@link ProofService#createRequestAsResponse}.
     *
     * @param proofRequestTemplate The proof request template
     * @param connectionRecord The connection for which to create the presentation request
     * @returns Object containing request message and associated proof record
     *
     */
    async createRequest(proofRequest, connectionRecord, config) {
        this.logger.debug(`Creating proof request`);
        // Assert
        connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.assertReady();
        // Create message
        const attachment = new Attachment_1.Attachment({
            id: messages_1.INDY_PROOF_REQUEST_ATTACHMENT_ID,
            mimeType: 'application/json',
            data: new Attachment_1.AttachmentData({
                base64: JsonEncoder_1.JsonEncoder.toBase64(proofRequest),
            }),
        });
        const requestPresentationMessage = new messages_1.RequestPresentationMessage({
            comment: config === null || config === void 0 ? void 0 : config.comment,
            requestPresentationAttachments: [attachment],
        });
        // Create record
        const proofRecord = new ProofRecord_1.ProofRecord({
            connectionId: connectionRecord === null || connectionRecord === void 0 ? void 0 : connectionRecord.id,
            threadId: requestPresentationMessage.threadId,
            requestMessage: requestPresentationMessage,
            state: ProofState_1.ProofState.RequestSent,
            autoAcceptProof: config === null || config === void 0 ? void 0 : config.autoAcceptProof,
        });
        await this.proofRepository.save(proofRecord);
        this.eventEmitter.emit({
            type: ProofEvents_1.ProofEventTypes.ProofStateChanged,
            payload: { proofRecord, previousState: null },
        });
        return { message: requestPresentationMessage, proofRecord };
    }
    /**
     * Process a received {@link RequestPresentationMessage}. This will not accept the presentation request
     * or send a presentation. It will only create a new, or update the existing proof record with
     * the information from the presentation request message. Use {@link ProofService.createPresentation}
     * after calling this method to create a presentation.
     *
     * @param messageContext The message context containing a presentation request message
     * @returns proof record associated with the presentation request message
     *
     */
    async processRequest(messageContext) {
        let proofRecord;
        const { message: proofRequestMessage, connection } = messageContext;
        this.logger.debug(`Processing presentation request with id ${proofRequestMessage.id}`);
        const proofRequest = proofRequestMessage.indyProofRequest;
        // Assert attachment
        if (!proofRequest) {
            throw new errors_1.PresentationProblemReportError(`Missing required base64 or json encoded attachment data for presentation request with thread id ${proofRequestMessage.threadId}`, { problemCode: errors_1.PresentationProblemReportReason.Abandoned });
        }
        await class_validator_1.validateOrReject(proofRequest);
        this.logger.debug('received proof request', proofRequest);
        try {
            // Proof record already exists
            proofRecord = await this.getByThreadAndConnectionId(proofRequestMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
            // Assert
            proofRecord.assertState(ProofState_1.ProofState.ProposalSent);
            this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
                previousReceivedMessage: proofRecord.requestMessage,
                previousSentMessage: proofRecord.proposalMessage,
            });
            // Update record
            proofRecord.requestMessage = proofRequestMessage;
            await this.updateState(proofRecord, ProofState_1.ProofState.RequestReceived);
        }
        catch (_a) {
            // No proof record exists with thread id
            proofRecord = new ProofRecord_1.ProofRecord({
                connectionId: connection === null || connection === void 0 ? void 0 : connection.id,
                threadId: proofRequestMessage.threadId,
                requestMessage: proofRequestMessage,
                state: ProofState_1.ProofState.RequestReceived,
            });
            // Assert
            this.connectionService.assertConnectionOrServiceDecorator(messageContext);
            // Save in repository
            await this.proofRepository.save(proofRecord);
            this.eventEmitter.emit({
                type: ProofEvents_1.ProofEventTypes.ProofStateChanged,
                payload: { proofRecord, previousState: null },
            });
        }
        return proofRecord;
    }
    /**
     * Create a {@link PresentationMessage} as response to a received presentation request.
     *
     * @param proofRecord The proof record for which to create the presentation
     * @param requestedCredentials The requested credentials object specifying which credentials to use for the proof
     * @param config Additional configuration to use for the presentation
     * @returns Object containing presentation message and associated proof record
     *
     */
    async createPresentation(proofRecord, requestedCredentials, config) {
        var _a;
        this.logger.debug(`Creating presentation for proof record with id ${proofRecord.id}`);
        // Assert
        proofRecord.assertState(ProofState_1.ProofState.RequestReceived);
        const indyProofRequest = (_a = proofRecord.requestMessage) === null || _a === void 0 ? void 0 : _a.indyProofRequest;
        if (!indyProofRequest) {
            throw new errors_1.PresentationProblemReportError(`Missing required base64 or json encoded attachment data for presentation with thread id ${proofRecord.threadId}`, { problemCode: errors_1.PresentationProblemReportReason.Abandoned });
        }
        // Get the matching attachments to the requested credentials
        const attachments = await this.getRequestedAttachmentsForRequestedCredentials(indyProofRequest, requestedCredentials);
        // Create proof
        const proof = await this.createProof(indyProofRequest, requestedCredentials);
        // Create message
        const attachment = new Attachment_1.Attachment({
            id: messages_1.INDY_PROOF_ATTACHMENT_ID,
            mimeType: 'application/json',
            data: new Attachment_1.AttachmentData({
                base64: JsonEncoder_1.JsonEncoder.toBase64(proof),
            }),
        });
        const presentationMessage = new messages_1.PresentationMessage({
            comment: config === null || config === void 0 ? void 0 : config.comment,
            presentationAttachments: [attachment],
            attachments,
        });
        presentationMessage.setThread({ threadId: proofRecord.threadId });
        // Update record
        proofRecord.presentationMessage = presentationMessage;
        await this.updateState(proofRecord, ProofState_1.ProofState.PresentationSent);
        return { message: presentationMessage, proofRecord };
    }
    /**
     * Process a received {@link PresentationMessage}. This will not accept the presentation
     * or send a presentation acknowledgement. It will only update the existing proof record with
     * the information from the presentation message. Use {@link ProofService.createAck}
     * after calling this method to create a presentation acknowledgement.
     *
     * @param messageContext The message context containing a presentation message
     * @returns proof record associated with the presentation message
     *
     */
    async processPresentation(messageContext) {
        var _a;
        const { message: presentationMessage, connection } = messageContext;
        this.logger.debug(`Processing presentation with id ${presentationMessage.id}`);
        const proofRecord = await this.getByThreadAndConnectionId(presentationMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        // Assert
        proofRecord.assertState(ProofState_1.ProofState.RequestSent);
        this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: proofRecord.proposalMessage,
            previousSentMessage: proofRecord.requestMessage,
        });
        // TODO: add proof class with validator
        const indyProofJson = presentationMessage.indyProof;
        const indyProofRequest = (_a = proofRecord.requestMessage) === null || _a === void 0 ? void 0 : _a.indyProofRequest;
        if (!indyProofJson) {
            throw new errors_1.PresentationProblemReportError(`Missing required base64 or json encoded attachment data for presentation with thread id ${presentationMessage.threadId}`, { problemCode: errors_1.PresentationProblemReportReason.Abandoned });
        }
        if (!indyProofRequest) {
            throw new errors_1.PresentationProblemReportError(`Missing required base64 or json encoded attachment data for presentation request with thread id ${presentationMessage.threadId}`, { problemCode: errors_1.PresentationProblemReportReason.Abandoned });
        }
        const isValid = await this.verifyProof(indyProofJson, indyProofRequest);
        // Update record
        proofRecord.isVerified = isValid;
        proofRecord.presentationMessage = presentationMessage;
        await this.updateState(proofRecord, ProofState_1.ProofState.PresentationReceived);
        return proofRecord;
    }
    /**
     * Create a {@link PresentationAckMessage} as response to a received presentation.
     *
     * @param proofRecord The proof record for which to create the presentation acknowledgement
     * @returns Object containing presentation acknowledgement message and associated proof record
     *
     */
    async createAck(proofRecord) {
        this.logger.debug(`Creating presentation ack for proof record with id ${proofRecord.id}`);
        // Assert
        proofRecord.assertState(ProofState_1.ProofState.PresentationReceived);
        // Create message
        const ackMessage = new messages_1.PresentationAckMessage({
            status: common_1.AckStatus.OK,
            threadId: proofRecord.threadId,
        });
        // Update record
        await this.updateState(proofRecord, ProofState_1.ProofState.Done);
        return { message: ackMessage, proofRecord };
    }
    /**
     * Process a received {@link PresentationAckMessage}.
     *
     * @param messageContext The message context containing a presentation acknowledgement message
     * @returns proof record associated with the presentation acknowledgement message
     *
     */
    async processAck(messageContext) {
        const { message: presentationAckMessage, connection } = messageContext;
        this.logger.debug(`Processing presentation ack with id ${presentationAckMessage.id}`);
        const proofRecord = await this.getByThreadAndConnectionId(presentationAckMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        // Assert
        proofRecord.assertState(ProofState_1.ProofState.PresentationSent);
        this.connectionService.assertConnectionOrServiceDecorator(messageContext, {
            previousReceivedMessage: proofRecord.requestMessage,
            previousSentMessage: proofRecord.presentationMessage,
        });
        // Update record
        await this.updateState(proofRecord, ProofState_1.ProofState.Done);
        return proofRecord;
    }
    /**
     * Process a received {@link PresentationProblemReportMessage}.
     *
     * @param messageContext The message context containing a presentation problem report message
     * @returns proof record associated with the presentation acknowledgement message
     *
     */
    async processProblemReport(messageContext) {
        const { message: presentationProblemReportMessage } = messageContext;
        const connection = messageContext.assertReadyConnection();
        this.logger.debug(`Processing problem report with id ${presentationProblemReportMessage.id}`);
        const proofRecord = await this.getByThreadAndConnectionId(presentationProblemReportMessage.threadId, connection === null || connection === void 0 ? void 0 : connection.id);
        proofRecord.errorMessage = `${presentationProblemReportMessage.description.code}: ${presentationProblemReportMessage.description.en}`;
        await this.update(proofRecord);
        return proofRecord;
    }
    async generateProofRequestNonce() {
        return this.wallet.generateNonce();
    }
    /**
     * Create a {@link ProofRequest} from a presentation proposal. This method can be used to create the
     * proof request from a received proposal for use in {@link ProofService.createRequestAsResponse}
     *
     * @param presentationProposal The presentation proposal to create a proof request from
     * @param config Additional configuration to use for the proof request
     * @returns proof request object
     *
     */
    async createProofRequestFromProposal(presentationProposal, config) {
        var _a;
        const nonce = (_a = config.nonce) !== null && _a !== void 0 ? _a : (await this.generateProofRequestNonce());
        const proofRequest = new models_1.ProofRequest({
            name: config.name,
            version: config.version,
            nonce,
        });
        /**
         * Create mapping of attributes by referent. This required the
         * attributes to come from the same credential.
         * @see https://github.com/hyperledger/aries-rfcs/blob/master/features/0037-present-proof/README.md#referent
         *
         * {
         *  "referent1": [Attribute1, Attribute2],
         *  "referent2": [Attribute3]
         * }
         */
        const attributesByReferent = {};
        for (const proposedAttributes of presentationProposal.attributes) {
            if (!proposedAttributes.referent)
                proposedAttributes.referent = uuid_1.uuid();
            const referentAttributes = attributesByReferent[proposedAttributes.referent];
            // Referent key already exist, add to list
            if (referentAttributes) {
                referentAttributes.push(proposedAttributes);
            }
            // Referent key does not exist yet, create new entry
            else {
                attributesByReferent[proposedAttributes.referent] = [proposedAttributes];
            }
        }
        // Transform attributes by referent to requested attributes
        for (const [referent, proposedAttributes] of Object.entries(attributesByReferent)) {
            // Either attributeName or attributeNames will be undefined
            const attributeName = proposedAttributes.length == 1 ? proposedAttributes[0].name : undefined;
            const attributeNames = proposedAttributes.length > 1 ? proposedAttributes.map((a) => a.name) : undefined;
            const requestedAttribute = new models_1.ProofAttributeInfo({
                name: attributeName,
                names: attributeNames,
                restrictions: [
                    new models_1.AttributeFilter({
                        credentialDefinitionId: proposedAttributes[0].credentialDefinitionId,
                    }),
                ],
            });
            proofRequest.requestedAttributes.set(referent, requestedAttribute);
        }
        this.logger.debug('proposal predicates', presentationProposal.predicates);
        // Transform proposed predicates to requested predicates
        for (const proposedPredicate of presentationProposal.predicates) {
            const requestedPredicate = new models_1.ProofPredicateInfo({
                name: proposedPredicate.name,
                predicateType: proposedPredicate.predicate,
                predicateValue: proposedPredicate.threshold,
                restrictions: [
                    new models_1.AttributeFilter({
                        credentialDefinitionId: proposedPredicate.credentialDefinitionId,
                    }),
                ],
            });
            proofRequest.requestedPredicates.set(uuid_1.uuid(), requestedPredicate);
        }
        return proofRequest;
    }
    /**
     * Retrieves the linked attachments for an {@link indyProofRequest}
     * @param indyProofRequest The proof request for which the linked attachments have to be found
     * @param requestedCredentials The requested credentials
     * @returns a list of attachments that are linked to the requested credentials
     */
    async getRequestedAttachmentsForRequestedCredentials(indyProofRequest, requestedCredentials) {
        var _a, _b;
        const attachments = [];
        const credentialIds = new Set();
        const requestedAttributesNames = [];
        // Get the credentialIds if it contains a hashlink
        for (const [referent, requestedAttribute] of Object.entries(requestedCredentials.requestedAttributes)) {
            // Find the requested Attributes
            const requestedAttributes = indyProofRequest.requestedAttributes.get(referent);
            // List the requested attributes
            requestedAttributesNames.push(...((_a = requestedAttributes.names) !== null && _a !== void 0 ? _a : [requestedAttributes.name]));
            // Find the attributes that have a hashlink as a value
            for (const attribute of Object.values(requestedAttribute.credentialInfo.attributes)) {
                if (attribute.toLowerCase().startsWith('hl:')) {
                    credentialIds.add(requestedAttribute.credentialId);
                }
            }
        }
        // Only continues if there is an attribute value that contains a hashlink
        for (const credentialId of credentialIds) {
            // Get the credentialRecord that matches the ID
            const credentialRecord = await this.credentialRepository.getSingleByQuery({ credentialId });
            if (credentialRecord.linkedAttachments) {
                // Get the credentials that have a hashlink as value and are requested
                const requestedCredentials = (_b = credentialRecord.credentialAttributes) === null || _b === void 0 ? void 0 : _b.filter((credential) => credential.value.toLowerCase().startsWith('hl:') && requestedAttributesNames.includes(credential.name));
                // Get the linked attachments that match the requestedCredentials
                const linkedAttachments = credentialRecord.linkedAttachments.filter((attachment) => requestedCredentials === null || requestedCredentials === void 0 ? void 0 : requestedCredentials.map((credential) => credential.value.split(':')[1]).includes(attachment.id));
                if (linkedAttachments) {
                    attachments.push(...linkedAttachments);
                }
            }
        }
        return attachments.length ? attachments : undefined;
    }
    /**
     * Create a {@link RetrievedCredentials} object. Given input proof request and presentation proposal,
     * use credentials in the wallet to build indy requested credentials object for input to proof creation.
     * If restrictions allow, self attested attributes will be used.
     *
     *
     * @param proofRequest The proof request to build the requested credentials object from
     * @param presentationProposal Optional presentation proposal to improve credential selection algorithm
     * @returns RetrievedCredentials object
     */
    async getRequestedCredentialsForProofRequest(proofRequest, presentationProposal) {
        var _a;
        const retrievedCredentials = new models_1.RetrievedCredentials({});
        for (const [referent, requestedAttribute] of proofRequest.requestedAttributes.entries()) {
            let credentialMatch = [];
            const credentials = await this.getCredentialsForProofRequest(proofRequest, referent);
            // If we have exactly one credential, or no proposal to pick preferences
            // on the credentials to use, we will use the first one
            if (credentials.length === 1 || !presentationProposal) {
                credentialMatch = credentials;
            }
            // If we have a proposal we will use that to determine the credentials to use
            else {
                const names = (_a = requestedAttribute.names) !== null && _a !== void 0 ? _a : [requestedAttribute.name];
                // Find credentials that matches all parameters from the proposal
                credentialMatch = credentials.filter((credential) => {
                    const { attributes, credentialDefinitionId } = credential.credentialInfo;
                    // Check if credentials matches all parameters from proposal
                    return names.every((name) => presentationProposal.attributes.find((a) => a.name === name &&
                        a.credentialDefinitionId === credentialDefinitionId &&
                        (!a.value || a.value === attributes[name])));
                });
            }
            retrievedCredentials.requestedAttributes[referent] = credentialMatch.map((credential) => {
                return new models_1.RequestedAttribute({
                    credentialId: credential.credentialInfo.referent,
                    revealed: true,
                    credentialInfo: credential.credentialInfo,
                });
            });
        }
        for (const [referent] of proofRequest.requestedPredicates.entries()) {
            const credentials = await this.getCredentialsForProofRequest(proofRequest, referent);
            retrievedCredentials.requestedPredicates[referent] = credentials.map((credential) => {
                return new models_1.RequestedPredicate({
                    credentialId: credential.credentialInfo.referent,
                    credentialInfo: credential.credentialInfo,
                });
            });
        }
        return retrievedCredentials;
    }
    /**
     * Takes a RetrievedCredentials object and auto selects credentials in a RequestedCredentials object
     *
     * Use the return value of this method as input to {@link ProofService.createPresentation} to
     * automatically accept a received presentation request.
     *
     * @param retrievedCredentials The retrieved credentials object to get credentials from
     *
     * @returns RequestedCredentials
     */
    autoSelectCredentialsForProofRequest(retrievedCredentials) {
        const requestedCredentials = new models_1.RequestedCredentials({});
        Object.keys(retrievedCredentials.requestedAttributes).forEach((attributeName) => {
            const attributeArray = retrievedCredentials.requestedAttributes[attributeName];
            if (attributeArray.length === 0) {
                throw new error_1.AriesFrameworkError('Unable to automatically select requested attributes.');
            }
            else {
                requestedCredentials.requestedAttributes[attributeName] = attributeArray[0];
            }
        });
        Object.keys(retrievedCredentials.requestedPredicates).forEach((attributeName) => {
            if (retrievedCredentials.requestedPredicates[attributeName].length === 0) {
                throw new error_1.AriesFrameworkError('Unable to automatically select requested predicates.');
            }
            else {
                requestedCredentials.requestedPredicates[attributeName] =
                    retrievedCredentials.requestedPredicates[attributeName][0];
            }
        });
        return requestedCredentials;
    }
    /**
     * Verify an indy proof object. Will also verify raw values against encodings.
     *
     * @param proofRequest The proof request to use for proof verification
     * @param proofJson The proof object to verify
     * @throws {Error} If the raw values do not match the encoded values
     * @returns Boolean whether the proof is valid
     *
     */
    async verifyProof(proofJson, proofRequest) {
        const proof = JsonTransformer_1.JsonTransformer.fromJSON(proofJson, models_1.PartialProof);
        for (const [referent, attribute] of proof.requestedProof.revealedAttributes.entries()) {
            if (!credentials_1.CredentialUtils.checkValidEncoding(attribute.raw, attribute.encoded)) {
                throw new errors_1.PresentationProblemReportError(`The encoded value for '${referent}' is invalid. ` +
                    `Expected '${credentials_1.CredentialUtils.encode(attribute.raw)}'. ` +
                    `Actual '${attribute.encoded}'`, { problemCode: errors_1.PresentationProblemReportReason.Abandoned });
            }
        }
        // TODO: pre verify proof json
        // I'm not 100% sure how much indy does. Also if it checks whether the proof requests matches the proof
        // @see https://github.com/hyperledger/aries-cloudagent-python/blob/master/aries_cloudagent/indy/sdk/verifier.py#L79-L164
        const schemas = await this.getSchemas(new Set(proof.identifiers.map((i) => i.schemaId)));
        const credentialDefinitions = await this.getCredentialDefinitions(new Set(proof.identifiers.map((i) => i.credentialDefinitionId)));
        return await this.indyVerifierService.verifyProof({
            proofRequest: proofRequest.toJSON(),
            proof: proofJson,
            schemas,
            credentialDefinitions,
        });
    }
    /**
     * Retrieve all proof records
     *
     * @returns List containing all proof records
     */
    async getAll() {
        return this.proofRepository.getAll();
    }
    /**
     * Retrieve a proof record by id
     *
     * @param proofRecordId The proof record id
     * @throws {RecordNotFoundError} If no record is found
     * @return The proof record
     *
     */
    async getById(proofRecordId) {
        return this.proofRepository.getById(proofRecordId);
    }
    /**
     * Retrieve a proof record by id
     *
     * @param proofRecordId The proof record id
     * @return The proof record or null if not found
     *
     */
    async findById(proofRecordId) {
        return this.proofRepository.findById(proofRecordId);
    }
    /**
     * Delete a proof record by id
     *
     * @param proofId the proof record id
     */
    async deleteById(proofId) {
        const proofRecord = await this.getById(proofId);
        return this.proofRepository.delete(proofRecord);
    }
    /**
     * Retrieve a proof record by connection id and thread id
     *
     * @param connectionId The connection id
     * @param threadId The thread id
     * @throws {RecordNotFoundError} If no record is found
     * @throws {RecordDuplicateError} If multiple records are found
     * @returns The proof record
     */
    async getByThreadAndConnectionId(threadId, connectionId) {
        return this.proofRepository.getSingleByQuery({ threadId, connectionId });
    }
    update(proofRecord) {
        return this.proofRepository.update(proofRecord);
    }
    /**
     * Create indy proof from a given proof request and requested credential object.
     *
     * @param proofRequest The proof request to create the proof for
     * @param requestedCredentials The requested credentials object specifying which credentials to use for the proof
     * @returns indy proof object
     */
    async createProof(proofRequest, requestedCredentials) {
        const credentialObjects = [
            ...Object.values(requestedCredentials.requestedAttributes),
            ...Object.values(requestedCredentials.requestedPredicates),
        ].map((c) => c.credentialInfo);
        const schemas = await this.getSchemas(new Set(credentialObjects.map((c) => c.schemaId)));
        const credentialDefinitions = await this.getCredentialDefinitions(new Set(credentialObjects.map((c) => c.credentialDefinitionId)));
        const proof = await this.indyHolderService.createProof({
            proofRequest: proofRequest.toJSON(),
            requestedCredentials: requestedCredentials.toJSON(),
            schemas,
            credentialDefinitions,
        });
        return proof;
    }
    async getCredentialsForProofRequest(proofRequest, attributeReferent) {
        const credentialsJson = await this.indyHolderService.getCredentialsForProofRequest({
            proofRequest: proofRequest.toJSON(),
            attributeReferent,
        });
        return JsonTransformer_1.JsonTransformer.fromJSON(credentialsJson, credentials_1.Credential);
    }
    /**
     * Update the record to a new state and emit an state changed event. Also updates the record
     * in storage.
     *
     * @param proofRecord The proof record to update the state for
     * @param newState The state to update to
     *
     */
    async updateState(proofRecord, newState) {
        const previousState = proofRecord.state;
        proofRecord.state = newState;
        await this.proofRepository.update(proofRecord);
        this.eventEmitter.emit({
            type: ProofEvents_1.ProofEventTypes.ProofStateChanged,
            payload: { proofRecord, previousState: previousState },
        });
    }
    /**
     * Build schemas object needed to create and verify proof objects.
     *
     * Creates object with `{ schemaId: Schema }` mapping
     *
     * @param schemaIds List of schema ids
     * @returns Object containing schemas for specified schema ids
     *
     */
    async getSchemas(schemaIds) {
        const schemas = {};
        for (const schemaId of schemaIds) {
            const schema = await this.ledgerService.getSchema(schemaId);
            schemas[schemaId] = schema;
        }
        return schemas;
    }
    /**
     * Build credential definitions object needed to create and verify proof objects.
     *
     * Creates object with `{ credentialDefinitionId: CredentialDefinition }` mapping
     *
     * @param credentialDefinitionIds List of credential definition ids
     * @returns Object containing credential definitions for specified credential definition ids
     *
     */
    async getCredentialDefinitions(credentialDefinitionIds) {
        const credentialDefinitions = {};
        for (const credDefId of credentialDefinitionIds) {
            const credDef = await this.ledgerService.getCredentialDefinition(credDefId);
            credentialDefinitions[credDefId] = credDef;
        }
        return credentialDefinitions;
    }
};
ProofService = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __param(2, tsyringe_1.inject(constants_1.InjectionSymbols.Wallet)),
    __metadata("design:paramtypes", [repository_1.ProofRepository,
        IndyLedgerService_1.IndyLedgerService, Object, AgentConfig_1.AgentConfig,
        indy_1.IndyHolderService,
        indy_1.IndyVerifierService,
        connections_1.ConnectionService,
        EventEmitter_1.EventEmitter,
        credentials_1.CredentialRepository])
], ProofService);
exports.ProofService = ProofService;
//# sourceMappingURL=ProofService.js.map
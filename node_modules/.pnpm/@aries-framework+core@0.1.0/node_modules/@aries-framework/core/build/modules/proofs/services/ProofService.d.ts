import type { AgentMessage } from '../../../agent/AgentMessage';
import type { InboundMessageContext } from '../../../agent/models/InboundMessageContext';
import type { ConnectionRecord } from '../../connections';
import type { AutoAcceptProof } from '../ProofAutoAcceptType';
import type { PresentationPreview } from '../messages';
import type { PresentationProblemReportMessage } from './../messages/PresentationProblemReportMessage';
import type { IndyProof } from 'indy-sdk';
import { AgentConfig } from '../../../agent/AgentConfig';
import { EventEmitter } from '../../../agent/EventEmitter';
import { Attachment } from '../../../decorators/attachment/Attachment';
import { Wallet } from '../../../wallet/Wallet';
import { ConnectionService } from '../../connections';
import { CredentialRepository } from '../../credentials';
import { IndyHolderService, IndyVerifierService } from '../../indy';
import { IndyLedgerService } from '../../ledger/services/IndyLedgerService';
import { PresentationAckMessage, PresentationMessage, ProposePresentationMessage, RequestPresentationMessage } from '../messages';
import { ProofRequest, RequestedCredentials, RetrievedCredentials } from '../models';
import { ProofRepository } from '../repository';
import { ProofRecord } from '../repository/ProofRecord';
/**
 * @todo add method to check if request matches proposal. Useful to see if a request I received is the same as the proposal I sent.
 * @todo add method to reject / revoke messages
 * @todo validate attachments / messages
 */
export declare class ProofService {
    private proofRepository;
    private credentialRepository;
    private ledgerService;
    private wallet;
    private logger;
    private indyHolderService;
    private indyVerifierService;
    private connectionService;
    private eventEmitter;
    constructor(proofRepository: ProofRepository, ledgerService: IndyLedgerService, wallet: Wallet, agentConfig: AgentConfig, indyHolderService: IndyHolderService, indyVerifierService: IndyVerifierService, connectionService: ConnectionService, eventEmitter: EventEmitter, credentialRepository: CredentialRepository);
    /**
     * Create a {@link ProposePresentationMessage} not bound to an existing presentation exchange.
     * To create a proposal as response to an existing presentation exchange, use {@link ProofService.createProposalAsResponse}.
     *
     * @param connectionRecord The connection for which to create the presentation proposal
     * @param presentationProposal The presentation proposal to include in the message
     * @param config Additional configuration to use for the proposal
     * @returns Object containing proposal message and associated proof record
     *
     */
    createProposal(connectionRecord: ConnectionRecord, presentationProposal: PresentationPreview, config?: {
        comment?: string;
        autoAcceptProof?: AutoAcceptProof;
    }): Promise<ProofProtocolMsgReturnType<ProposePresentationMessage>>;
    /**
     * Create a {@link ProposePresentationMessage} as response to a received presentation request.
     * To create a proposal not bound to an existing presentation exchange, use {@link ProofService.createProposal}.
     *
     * @param proofRecord The proof record for which to create the presentation proposal
     * @param presentationProposal The presentation proposal to include in the message
     * @param config Additional configuration to use for the proposal
     * @returns Object containing proposal message and associated proof record
     *
     */
    createProposalAsResponse(proofRecord: ProofRecord, presentationProposal: PresentationPreview, config?: {
        comment?: string;
    }): Promise<ProofProtocolMsgReturnType<ProposePresentationMessage>>;
    /**
     * Decline a proof request
     * @param proofRecord The proof request to be declined
     */
    declineRequest(proofRecord: ProofRecord): Promise<ProofRecord>;
    /**
     * Process a received {@link ProposePresentationMessage}. This will not accept the presentation proposal
     * or send a presentation request. It will only create a new, or update the existing proof record with
     * the information from the presentation proposal message. Use {@link ProofService.createRequestAsResponse}
     * after calling this method to create a presentation request.
     *
     * @param messageContext The message context containing a presentation proposal message
     * @returns proof record associated with the presentation proposal message
     *
     */
    processProposal(messageContext: InboundMessageContext<ProposePresentationMessage>): Promise<ProofRecord>;
    /**
     * Create a {@link RequestPresentationMessage} as response to a received presentation proposal.
     * To create a request not bound to an existing presentation exchange, use {@link ProofService.createRequest}.
     *
     * @param proofRecord The proof record for which to create the presentation request
     * @param proofRequest The proof request to include in the message
     * @param config Additional configuration to use for the request
     * @returns Object containing request message and associated proof record
     *
     */
    createRequestAsResponse(proofRecord: ProofRecord, proofRequest: ProofRequest, config?: {
        comment?: string;
    }): Promise<ProofProtocolMsgReturnType<RequestPresentationMessage>>;
    /**
     * Create a {@link RequestPresentationMessage} not bound to an existing presentation exchange.
     * To create a request as response to an existing presentation exchange, use {@link ProofService#createRequestAsResponse}.
     *
     * @param proofRequestTemplate The proof request template
     * @param connectionRecord The connection for which to create the presentation request
     * @returns Object containing request message and associated proof record
     *
     */
    createRequest(proofRequest: ProofRequest, connectionRecord?: ConnectionRecord, config?: {
        comment?: string;
        autoAcceptProof?: AutoAcceptProof;
    }): Promise<ProofProtocolMsgReturnType<RequestPresentationMessage>>;
    /**
     * Process a received {@link RequestPresentationMessage}. This will not accept the presentation request
     * or send a presentation. It will only create a new, or update the existing proof record with
     * the information from the presentation request message. Use {@link ProofService.createPresentation}
     * after calling this method to create a presentation.
     *
     * @param messageContext The message context containing a presentation request message
     * @returns proof record associated with the presentation request message
     *
     */
    processRequest(messageContext: InboundMessageContext<RequestPresentationMessage>): Promise<ProofRecord>;
    /**
     * Create a {@link PresentationMessage} as response to a received presentation request.
     *
     * @param proofRecord The proof record for which to create the presentation
     * @param requestedCredentials The requested credentials object specifying which credentials to use for the proof
     * @param config Additional configuration to use for the presentation
     * @returns Object containing presentation message and associated proof record
     *
     */
    createPresentation(proofRecord: ProofRecord, requestedCredentials: RequestedCredentials, config?: {
        comment?: string;
    }): Promise<ProofProtocolMsgReturnType<PresentationMessage>>;
    /**
     * Process a received {@link PresentationMessage}. This will not accept the presentation
     * or send a presentation acknowledgement. It will only update the existing proof record with
     * the information from the presentation message. Use {@link ProofService.createAck}
     * after calling this method to create a presentation acknowledgement.
     *
     * @param messageContext The message context containing a presentation message
     * @returns proof record associated with the presentation message
     *
     */
    processPresentation(messageContext: InboundMessageContext<PresentationMessage>): Promise<ProofRecord>;
    /**
     * Create a {@link PresentationAckMessage} as response to a received presentation.
     *
     * @param proofRecord The proof record for which to create the presentation acknowledgement
     * @returns Object containing presentation acknowledgement message and associated proof record
     *
     */
    createAck(proofRecord: ProofRecord): Promise<ProofProtocolMsgReturnType<PresentationAckMessage>>;
    /**
     * Process a received {@link PresentationAckMessage}.
     *
     * @param messageContext The message context containing a presentation acknowledgement message
     * @returns proof record associated with the presentation acknowledgement message
     *
     */
    processAck(messageContext: InboundMessageContext<PresentationAckMessage>): Promise<ProofRecord>;
    /**
     * Process a received {@link PresentationProblemReportMessage}.
     *
     * @param messageContext The message context containing a presentation problem report message
     * @returns proof record associated with the presentation acknowledgement message
     *
     */
    processProblemReport(messageContext: InboundMessageContext<PresentationProblemReportMessage>): Promise<ProofRecord>;
    generateProofRequestNonce(): Promise<string>;
    /**
     * Create a {@link ProofRequest} from a presentation proposal. This method can be used to create the
     * proof request from a received proposal for use in {@link ProofService.createRequestAsResponse}
     *
     * @param presentationProposal The presentation proposal to create a proof request from
     * @param config Additional configuration to use for the proof request
     * @returns proof request object
     *
     */
    createProofRequestFromProposal(presentationProposal: PresentationPreview, config: {
        name: string;
        version: string;
        nonce?: string;
    }): Promise<ProofRequest>;
    /**
     * Retrieves the linked attachments for an {@link indyProofRequest}
     * @param indyProofRequest The proof request for which the linked attachments have to be found
     * @param requestedCredentials The requested credentials
     * @returns a list of attachments that are linked to the requested credentials
     */
    getRequestedAttachmentsForRequestedCredentials(indyProofRequest: ProofRequest, requestedCredentials: RequestedCredentials): Promise<Attachment[] | undefined>;
    /**
     * Create a {@link RetrievedCredentials} object. Given input proof request and presentation proposal,
     * use credentials in the wallet to build indy requested credentials object for input to proof creation.
     * If restrictions allow, self attested attributes will be used.
     *
     *
     * @param proofRequest The proof request to build the requested credentials object from
     * @param presentationProposal Optional presentation proposal to improve credential selection algorithm
     * @returns RetrievedCredentials object
     */
    getRequestedCredentialsForProofRequest(proofRequest: ProofRequest, presentationProposal?: PresentationPreview): Promise<RetrievedCredentials>;
    /**
     * Takes a RetrievedCredentials object and auto selects credentials in a RequestedCredentials object
     *
     * Use the return value of this method as input to {@link ProofService.createPresentation} to
     * automatically accept a received presentation request.
     *
     * @param retrievedCredentials The retrieved credentials object to get credentials from
     *
     * @returns RequestedCredentials
     */
    autoSelectCredentialsForProofRequest(retrievedCredentials: RetrievedCredentials): RequestedCredentials;
    /**
     * Verify an indy proof object. Will also verify raw values against encodings.
     *
     * @param proofRequest The proof request to use for proof verification
     * @param proofJson The proof object to verify
     * @throws {Error} If the raw values do not match the encoded values
     * @returns Boolean whether the proof is valid
     *
     */
    verifyProof(proofJson: IndyProof, proofRequest: ProofRequest): Promise<boolean>;
    /**
     * Retrieve all proof records
     *
     * @returns List containing all proof records
     */
    getAll(): Promise<ProofRecord[]>;
    /**
     * Retrieve a proof record by id
     *
     * @param proofRecordId The proof record id
     * @throws {RecordNotFoundError} If no record is found
     * @return The proof record
     *
     */
    getById(proofRecordId: string): Promise<ProofRecord>;
    /**
     * Retrieve a proof record by id
     *
     * @param proofRecordId The proof record id
     * @return The proof record or null if not found
     *
     */
    findById(proofRecordId: string): Promise<ProofRecord | null>;
    /**
     * Delete a proof record by id
     *
     * @param proofId the proof record id
     */
    deleteById(proofId: string): Promise<void>;
    /**
     * Retrieve a proof record by connection id and thread id
     *
     * @param connectionId The connection id
     * @param threadId The thread id
     * @throws {RecordNotFoundError} If no record is found
     * @throws {RecordDuplicateError} If multiple records are found
     * @returns The proof record
     */
    getByThreadAndConnectionId(threadId: string, connectionId?: string): Promise<ProofRecord>;
    update(proofRecord: ProofRecord): Promise<void>;
    /**
     * Create indy proof from a given proof request and requested credential object.
     *
     * @param proofRequest The proof request to create the proof for
     * @param requestedCredentials The requested credentials object specifying which credentials to use for the proof
     * @returns indy proof object
     */
    private createProof;
    private getCredentialsForProofRequest;
    /**
     * Update the record to a new state and emit an state changed event. Also updates the record
     * in storage.
     *
     * @param proofRecord The proof record to update the state for
     * @param newState The state to update to
     *
     */
    private updateState;
    /**
     * Build schemas object needed to create and verify proof objects.
     *
     * Creates object with `{ schemaId: Schema }` mapping
     *
     * @param schemaIds List of schema ids
     * @returns Object containing schemas for specified schema ids
     *
     */
    private getSchemas;
    /**
     * Build credential definitions object needed to create and verify proof objects.
     *
     * Creates object with `{ credentialDefinitionId: CredentialDefinition }` mapping
     *
     * @param credentialDefinitionIds List of credential definition ids
     * @returns Object containing credential definitions for specified credential definition ids
     *
     */
    private getCredentialDefinitions;
}
export interface ProofRequestTemplate {
    proofRequest: ProofRequest;
    comment?: string;
}
export interface ProofProtocolMsgReturnType<MessageType extends AgentMessage> {
    message: MessageType;
    proofRecord: ProofRecord;
}

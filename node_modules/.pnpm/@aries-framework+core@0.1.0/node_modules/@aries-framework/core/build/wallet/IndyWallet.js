"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndyWallet = void 0;
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../agent/AgentConfig");
const error_1 = require("../error");
const JsonEncoder_1 = require("../utils/JsonEncoder");
const indyError_1 = require("../utils/indyError");
const error_2 = require("./error");
const WalletInvalidKeyError_1 = require("./error/WalletInvalidKeyError");
let IndyWallet = class IndyWallet {
    constructor(agentConfig) {
        this.logger = agentConfig.logger;
        this.indy = agentConfig.agentDependencies.indy;
    }
    get isProvisioned() {
        return this.walletConfig !== undefined;
    }
    get isInitialized() {
        return this.walletHandle !== undefined;
    }
    get publicDid() {
        return this.publicDidInfo;
    }
    get handle() {
        if (!this.walletHandle) {
            throw new error_1.AriesFrameworkError('Wallet has not been initialized yet. Make sure to await agent.initialize() before using the agent.');
        }
        return this.walletHandle;
    }
    get masterSecretId() {
        var _a;
        if (!this.isInitialized || !((_a = this.walletConfig) === null || _a === void 0 ? void 0 : _a.id)) {
            throw new error_1.AriesFrameworkError('Wallet has not been initialized yet. Make sure to await agent.initialize() before using the agent.');
        }
        return this.walletConfig.id;
    }
    async initialize(walletConfig) {
        this.logger.info(`Initializing wallet '${walletConfig.id}'`, walletConfig);
        if (this.isInitialized) {
            throw new error_2.WalletError('Wallet instance already initialized. Close the currently opened wallet before re-initializing the wallet');
        }
        // Open wallet, creating if it doesn't exist yet
        try {
            await this.open(walletConfig);
        }
        catch (error) {
            // If the wallet does not exist yet, create it and try to open again
            if (error instanceof error_2.WalletNotFoundError) {
                await this.create(walletConfig);
                await this.open(walletConfig);
            }
            else {
                throw error;
            }
        }
        this.logger.debug(`Wallet '${walletConfig.id}' initialized with handle '${this.handle}'`);
    }
    /**
     * @throws {WalletDuplicateError} if the wallet already exists
     * @throws {WalletError} if another error occurs
     */
    async create(walletConfig) {
        this.logger.debug(`Creating wallet '${walletConfig.id}' using SQLite storage`);
        try {
            await this.indy.createWallet({ id: walletConfig.id }, { key: walletConfig.key });
            this.walletConfig = {
                id: walletConfig.id,
                key: walletConfig.key,
            };
            // We usually want to create master secret only once, therefore, we can to do so when creating a wallet.
            await this.open(walletConfig);
            // We need to open wallet before creating master secret because we need wallet handle here.
            await this.createMasterSecret(this.handle, walletConfig.id);
            // We opened wallet just to create master secret, we can close it now.
            await this.close();
        }
        catch (error) {
            if (indyError_1.isIndyError(error, 'WalletAlreadyExistsError')) {
                const errorMessage = `Wallet '${walletConfig.id}' already exists`;
                this.logger.debug(errorMessage);
                throw new error_2.WalletDuplicateError(errorMessage, {
                    walletType: 'IndyWallet',
                    cause: error,
                });
            }
            else {
                const errorMessage = `Error creating wallet '${walletConfig.id}'`;
                this.logger.error(errorMessage, {
                    error,
                    errorMessage: error.message,
                });
                throw new error_2.WalletError(errorMessage, { cause: error });
            }
        }
    }
    /**
     * @throws {WalletNotFoundError} if the wallet does not exist
     * @throws {WalletError} if another error occurs
     */
    async open(walletConfig) {
        if (this.walletHandle) {
            throw new error_2.WalletError('Wallet instance already opened. Close the currently opened wallet before re-opening the wallet');
        }
        try {
            this.walletHandle = await this.indy.openWallet({ id: walletConfig.id }, { key: walletConfig.key });
            this.walletConfig = {
                id: walletConfig.id,
                key: walletConfig.key,
            };
        }
        catch (error) {
            if (indyError_1.isIndyError(error, 'WalletNotFoundError')) {
                const errorMessage = `Wallet '${walletConfig.id}' not found`;
                this.logger.debug(errorMessage);
                throw new error_2.WalletNotFoundError(errorMessage, {
                    walletType: 'IndyWallet',
                    cause: error,
                });
            }
            else if (indyError_1.isIndyError(error, 'WalletAccessFailed')) {
                const errorMessage = `Incorrect key for wallet '${walletConfig.id}'`;
                this.logger.debug(errorMessage);
                throw new WalletInvalidKeyError_1.WalletInvalidKeyError(errorMessage, {
                    walletType: 'IndyWallet',
                    cause: error,
                });
            }
            else {
                const errorMessage = `Error opening wallet '${walletConfig.id}'`;
                this.logger.error(errorMessage, {
                    error,
                    errorMessage: error.message,
                });
                throw new error_2.WalletError(errorMessage, { cause: error });
            }
        }
    }
    /**
     * @throws {WalletNotFoundError} if the wallet does not exist
     * @throws {WalletError} if another error occurs
     */
    async delete() {
        if (!this.walletConfig) {
            throw new error_2.WalletError('Can not delete wallet that does not have wallet config set. Make sure to call create wallet before deleting the wallet');
        }
        this.logger.info(`Deleting wallet '${this.walletConfig.id}'`);
        if (this.walletHandle) {
            await this.close();
        }
        try {
            await this.indy.deleteWallet({ id: this.walletConfig.id }, { key: this.walletConfig.key });
        }
        catch (error) {
            if (indyError_1.isIndyError(error, 'WalletNotFoundError')) {
                const errorMessage = `Error deleting wallet: wallet '${this.walletConfig.id}' not found`;
                this.logger.debug(errorMessage);
                throw new error_2.WalletNotFoundError(errorMessage, {
                    walletType: 'IndyWallet',
                    cause: error,
                });
            }
            else {
                const errorMessage = `Error deleting wallet '${this.walletConfig.id}': ${error.message}`;
                this.logger.error(errorMessage, {
                    error,
                    errorMessage: error.message,
                });
                throw new error_2.WalletError(errorMessage, { cause: error });
            }
        }
    }
    /**
     * @throws {WalletError} if the wallet is already closed or another error occurs
     */
    async close() {
        if (!this.walletHandle) {
            throw new error_2.WalletError('Wallet is in inavlid state, you are trying to close wallet that has no `walletHandle`.');
        }
        try {
            await this.indy.closeWallet(this.walletHandle);
            this.walletHandle = undefined;
            this.publicDidInfo = undefined;
        }
        catch (error) {
            if (indyError_1.isIndyError(error, 'WalletInvalidHandle')) {
                const errorMessage = `Error closing wallet: wallet already closed`;
                this.logger.debug(errorMessage);
                throw new error_2.WalletError(errorMessage, {
                    cause: error,
                });
            }
            else {
                const errorMessage = `Error closing wallet': ${error.message}`;
                this.logger.error(errorMessage, {
                    error,
                    errorMessage: error.message,
                });
                throw new error_2.WalletError(errorMessage, { cause: error });
            }
        }
    }
    /**
     * Create master secret with specified id in currently opened wallet.
     *
     * If a master secret by this id already exists in the current wallet, the method
     * will return without doing anything.
     *
     * @throws {WalletError} if an error occurs
     */
    async createMasterSecret(walletHandle, masterSecretId) {
        this.logger.debug(`Creating master secret with id '${masterSecretId}' in wallet with handle '${walletHandle}'`);
        try {
            await this.indy.proverCreateMasterSecret(walletHandle, masterSecretId);
            return masterSecretId;
        }
        catch (error) {
            if (indyError_1.isIndyError(error, 'AnoncredsMasterSecretDuplicateNameError')) {
                // master secret id is the same as the master secret id passed in the create function
                // so if it already exists we can just assign it.
                this.logger.debug(`Master secret with id '${masterSecretId}' already exists in wallet with handle '${walletHandle}'`, {
                    indyError: 'AnoncredsMasterSecretDuplicateNameError',
                });
                return masterSecretId;
            }
            else {
                this.logger.error(`Error creating master secret with id ${masterSecretId}`, {
                    indyError: error.indyName,
                    error,
                });
                throw new error_2.WalletError(`Error creating master secret with id ${masterSecretId} in wallet with handle '${walletHandle}'`, { cause: error });
            }
        }
    }
    async initPublicDid(didConfig) {
        const { did, verkey } = await this.createDid(didConfig);
        this.publicDidInfo = {
            did,
            verkey,
        };
    }
    async createDid(didConfig) {
        try {
            const [did, verkey] = await this.indy.createAndStoreMyDid(this.handle, didConfig || {});
            return { did, verkey };
        }
        catch (error) {
            throw new error_2.WalletError('Error creating Did', { cause: error });
        }
    }
    async pack(payload, recipientKeys, senderVerkey) {
        try {
            const messageRaw = JsonEncoder_1.JsonEncoder.toBuffer(payload);
            const packedMessage = await this.indy.packMessage(this.handle, messageRaw, recipientKeys, senderVerkey !== null && senderVerkey !== void 0 ? senderVerkey : null);
            return JsonEncoder_1.JsonEncoder.fromBuffer(packedMessage);
        }
        catch (error) {
            throw new error_2.WalletError('Error packing message', { cause: error });
        }
    }
    async unpack(messagePackage) {
        try {
            const unpackedMessageBuffer = await this.indy.unpackMessage(this.handle, JsonEncoder_1.JsonEncoder.toBuffer(messagePackage));
            const unpackedMessage = JsonEncoder_1.JsonEncoder.fromBuffer(unpackedMessageBuffer);
            return {
                senderKey: unpackedMessage.sender_verkey,
                recipientKey: unpackedMessage.recipient_verkey,
                plaintextMessage: JsonEncoder_1.JsonEncoder.fromString(unpackedMessage.message),
            };
        }
        catch (error) {
            throw new error_2.WalletError('Error unpacking message', { cause: error });
        }
    }
    async sign(data, verkey) {
        try {
            return await this.indy.cryptoSign(this.handle, verkey, data);
        }
        catch (error) {
            throw new error_2.WalletError(`Error signing data with verkey ${verkey}`, { cause: error });
        }
    }
    async verify(signerVerkey, data, signature) {
        try {
            // check signature
            const isValid = await this.indy.cryptoVerify(signerVerkey, data, signature);
            return isValid;
        }
        catch (error) {
            throw new error_2.WalletError(`Error verifying signature of data signed with verkey ${signerVerkey}`, { cause: error });
        }
    }
    async generateNonce() {
        try {
            return await this.indy.generateNonce();
        }
        catch (error) {
            throw new error_2.WalletError('Error generating nonce', { cause: error });
        }
    }
};
IndyWallet = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __metadata("design:paramtypes", [AgentConfig_1.AgentConfig])
], IndyWallet);
exports.IndyWallet = IndyWallet;
//# sourceMappingURL=IndyWallet.js.map
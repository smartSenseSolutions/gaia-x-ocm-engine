"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Repository = void 0;
const error_1 = require("../error");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class Repository {
    constructor(recordClass, storageService) {
        this.storageService = storageService;
        this.recordClass = recordClass;
    }
    /** @inheritDoc {StorageService#save} */
    async save(record) {
        return this.storageService.save(record);
    }
    /** @inheritDoc {StorageService#update} */
    async update(record) {
        return this.storageService.update(record);
    }
    /** @inheritDoc {StorageService#delete} */
    async delete(record) {
        return this.storageService.delete(record);
    }
    /** @inheritDoc {StorageService#getById} */
    async getById(id) {
        return this.storageService.getById(this.recordClass, id);
    }
    /**
     * Find record by id. Returns null if no record is found
     * @param id the id of the record to retrieve
     * @returns
     */
    async findById(id) {
        try {
            return await this.storageService.getById(this.recordClass, id);
        }
        catch (error) {
            if (error instanceof error_1.RecordNotFoundError)
                return null;
            throw error;
        }
    }
    /** @inheritDoc {StorageService#getAll} */
    async getAll() {
        return this.storageService.getAll(this.recordClass);
    }
    /** @inheritDoc {StorageService#findByQuery} */
    async findByQuery(query) {
        return this.storageService.findByQuery(this.recordClass, query);
    }
    /**
     * Find a single record by query. Returns null if not found.
     * @param query the query
     * @returns the record, or null if not found
     * @throws {RecordDuplicateError} if multiple records are found for the given query
     */
    async findSingleByQuery(query) {
        const records = await this.findByQuery(query);
        if (records.length > 1) {
            throw new error_1.RecordDuplicateError(`Multiple records found for given query '${JSON.stringify(query)}'`, {
                recordType: this.recordClass.type,
            });
        }
        if (records.length < 1) {
            return null;
        }
        return records[0];
    }
    /**
     * Find a single record by query. Throws if not found
     * @param query the query
     * @returns the record
     * @throws {RecordDuplicateError} if multiple records are found for the given query
     * @throws {RecordNotFoundError} if no record is found for the given query
     */
    async getSingleByQuery(query) {
        const record = await this.findSingleByQuery(query);
        if (!record) {
            throw new error_1.RecordNotFoundError(`No record found for given query '${JSON.stringify(query)}'`, {
                recordType: this.recordClass.type,
            });
        }
        return record;
    }
}
exports.Repository = Repository;
//# sourceMappingURL=Repository.js.map
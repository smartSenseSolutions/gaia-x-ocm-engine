"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var IndyStorageService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndyStorageService = void 0;
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../agent/AgentConfig");
const error_1 = require("../error");
const JsonTransformer_1 = require("../utils/JsonTransformer");
const indyError_1 = require("../utils/indyError");
const type_1 = require("../utils/type");
const IndyWallet_1 = require("../wallet/IndyWallet");
let IndyStorageService = IndyStorageService_1 = class IndyStorageService {
    constructor(wallet, agentConfig) {
        this.wallet = wallet;
        this.indy = agentConfig.agentDependencies.indy;
    }
    transformToRecordTagValues(tags) {
        const transformedTags = {};
        for (const [key, value] of Object.entries(tags)) {
            // If the value is a boolean string ('1' or '0')
            // use the boolean val
            if (value === '1' && (value === null || value === void 0 ? void 0 : value.includes(':'))) {
                const [tagName, tagValue] = value.split(':');
                const transformedValue = transformedTags[tagName];
                if (Array.isArray(transformedValue)) {
                    transformedTags[tagName] = [...transformedValue, tagValue];
                }
                else {
                    transformedTags[tagName] = [tagValue];
                }
            }
            else if (value === '1' || value === '0') {
                transformedTags[key] = value === '1';
            }
            // Otherwise just use the value
            else {
                transformedTags[key] = value;
            }
        }
        return transformedTags;
    }
    transformFromRecordTagValues(tags) {
        const transformedTags = {};
        for (const [key, value] of Object.entries(tags)) {
            // If the value is a boolean use the indy
            // '1' or '0' syntax
            if (type_1.isBoolean(value)) {
                transformedTags[key] = value ? '1' : '0';
            }
            // If the value is an array we create a tag for each array
            // item ("tagName:arrayItem" = "1")
            else if (Array.isArray(value)) {
                value.forEach((item) => {
                    const tagName = `${key}:${item}`;
                    transformedTags[tagName] = '1';
                });
            }
            // Otherwise just use the value
            else {
                transformedTags[key] = value;
            }
        }
        return transformedTags;
    }
    recordToInstance(record, recordClass) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const instance = JsonTransformer_1.JsonTransformer.deserialize(record.value, recordClass);
        instance.id = record.id;
        const tags = record.tags ? this.transformToRecordTagValues(record.tags) : {};
        instance.replaceTags(tags);
        return instance;
    }
    /** @inheritDoc */
    async save(record) {
        const value = JsonTransformer_1.JsonTransformer.serialize(record);
        // FIXME: update @types/indy-sdk to be of type Record<string, string |undefined>
        const tags = this.transformFromRecordTagValues(record.getTags());
        try {
            await this.indy.addWalletRecord(this.wallet.handle, record.type, record.id, value, tags);
        }
        catch (error) {
            // Record already exists
            if (indyError_1.isIndyError(error, 'WalletItemAlreadyExists')) {
                throw new error_1.RecordDuplicateError(`Record with id ${record.id} already exists`, { recordType: record.type });
            }
            throw indyError_1.isIndyError(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    /** @inheritDoc */
    async update(record) {
        const value = JsonTransformer_1.JsonTransformer.serialize(record);
        // FIXME: update @types/indy-sdk to be of type Record<string, string |undefined>
        const tags = this.transformFromRecordTagValues(record.getTags());
        try {
            await this.indy.updateWalletRecordValue(this.wallet.handle, record.type, record.id, value);
            await this.indy.updateWalletRecordTags(this.wallet.handle, record.type, record.id, tags);
        }
        catch (error) {
            // Record does not exist
            if (indyError_1.isIndyError(error, 'WalletItemNotFound')) {
                throw new error_1.RecordNotFoundError(`record with id ${record.id} not found.`, {
                    recordType: record.type,
                    cause: error,
                });
            }
            throw indyError_1.isIndyError(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    /** @inheritDoc */
    async delete(record) {
        try {
            await this.indy.deleteWalletRecord(this.wallet.handle, record.type, record.id);
        }
        catch (error) {
            // Record does not exist
            if (indyError_1.isIndyError(error, 'WalletItemNotFound')) {
                throw new error_1.RecordNotFoundError(`record with id ${record.id} not found.`, {
                    recordType: record.type,
                    cause: error,
                });
            }
            throw indyError_1.isIndyError(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    /** @inheritDoc */
    async getById(recordClass, id) {
        try {
            const record = await this.indy.getWalletRecord(this.wallet.handle, recordClass.type, id, IndyStorageService_1.DEFAULT_QUERY_OPTIONS);
            return this.recordToInstance(record, recordClass);
        }
        catch (error) {
            if (indyError_1.isIndyError(error, 'WalletItemNotFound')) {
                throw new error_1.RecordNotFoundError(`record with id ${id} not found.`, {
                    recordType: recordClass.type,
                    cause: error,
                });
            }
            throw indyError_1.isIndyError(error) ? new error_1.IndySdkError(error) : error;
        }
    }
    /** @inheritDoc */
    async getAll(recordClass) {
        var e_1, _a;
        const recordIterator = this.search(recordClass.type, {}, IndyStorageService_1.DEFAULT_QUERY_OPTIONS);
        const records = [];
        try {
            for (var recordIterator_1 = __asyncValues(recordIterator), recordIterator_1_1; recordIterator_1_1 = await recordIterator_1.next(), !recordIterator_1_1.done;) {
                const record = recordIterator_1_1.value;
                records.push(this.recordToInstance(record, recordClass));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (recordIterator_1_1 && !recordIterator_1_1.done && (_a = recordIterator_1.return)) await _a.call(recordIterator_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return records;
    }
    /** @inheritDoc */
    async findByQuery(recordClass, query) {
        var e_2, _a;
        const indyQuery = this.transformFromRecordTagValues(query);
        const recordIterator = this.search(recordClass.type, indyQuery, IndyStorageService_1.DEFAULT_QUERY_OPTIONS);
        const records = [];
        try {
            for (var recordIterator_2 = __asyncValues(recordIterator), recordIterator_2_1; recordIterator_2_1 = await recordIterator_2.next(), !recordIterator_2_1.done;) {
                const record = recordIterator_2_1.value;
                records.push(this.recordToInstance(record, recordClass));
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (recordIterator_2_1 && !recordIterator_2_1.done && (_a = recordIterator_2.return)) await _a.call(recordIterator_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return records;
    }
    search(type, query, _a) {
        var { limit = Infinity } = _a, options = __rest(_a, ["limit"]);
        return __asyncGenerator(this, arguments, function* search_1() {
            try {
                const searchHandle = yield __await(this.indy.openWalletSearch(this.wallet.handle, type, query, options));
                let records = [];
                // Allow max of 256 per fetch operation
                const chunk = limit ? Math.min(256, limit) : 256;
                // Loop while limit not reached (or no limit specified)
                while (!limit || records.length < limit) {
                    // Retrieve records
                    const recordsJson = yield __await(this.indy.fetchWalletSearchNextRecords(this.wallet.handle, searchHandle, chunk)
                    // FIXME: update @types/indy-sdk: records can be null (if last reached)
                    );
                    // FIXME: update @types/indy-sdk: records can be null (if last reached)
                    if (recordsJson.records) {
                        records = [...records, ...recordsJson.records];
                        for (const record of recordsJson.records) {
                            yield yield __await(record);
                        }
                    }
                    // If the number of records returned is less than chunk
                    // It means we reached the end of the iterator (no more records)
                    if (!records.length || recordsJson.records.length < chunk) {
                        yield __await(this.indy.closeWalletSearch(searchHandle));
                        return yield __await(void 0);
                    }
                }
            }
            catch (error) {
                throw new error_1.IndySdkError(error);
            }
        });
    }
};
IndyStorageService.DEFAULT_QUERY_OPTIONS = {
    retrieveType: true,
    retrieveTags: true,
};
IndyStorageService = IndyStorageService_1 = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __metadata("design:paramtypes", [IndyWallet_1.IndyWallet, AgentConfig_1.AgentConfig])
], IndyStorageService);
exports.IndyStorageService = IndyStorageService;
//# sourceMappingURL=IndyStorageService.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Agent = void 0;
const operators_1 = require("rxjs/operators");
const tsyringe_1 = require("tsyringe");
const constants_1 = require("../constants");
const error_1 = require("../error");
const BasicMessagesModule_1 = require("../modules/basic-messages/BasicMessagesModule");
const ConnectionsModule_1 = require("../modules/connections/ConnectionsModule");
const CredentialsModule_1 = require("../modules/credentials/CredentialsModule");
const discover_features_1 = require("../modules/discover-features");
const LedgerModule_1 = require("../modules/ledger/LedgerModule");
const ProofsModule_1 = require("../modules/proofs/ProofsModule");
const MediatorModule_1 = require("../modules/routing/MediatorModule");
const RecipientModule_1 = require("../modules/routing/RecipientModule");
const InMemoryMessageRepository_1 = require("../storage/InMemoryMessageRepository");
const IndyStorageService_1 = require("../storage/IndyStorageService");
const IndyWallet_1 = require("../wallet/IndyWallet");
const error_2 = require("../wallet/error");
const AgentConfig_1 = require("./AgentConfig");
const EventEmitter_1 = require("./EventEmitter");
const Events_1 = require("./Events");
const MessageReceiver_1 = require("./MessageReceiver");
const MessageSender_1 = require("./MessageSender");
const TransportService_1 = require("./TransportService");
class Agent {
    constructor(initialConfig, dependencies) {
        this._isInitialized = false;
        // Create child container so we don't interfere with anything outside of this agent
        this.container = tsyringe_1.container.createChildContainer();
        this.agentConfig = new AgentConfig_1.AgentConfig(initialConfig, dependencies);
        this.logger = this.agentConfig.logger;
        // Bind class based instances
        this.container.registerInstance(AgentConfig_1.AgentConfig, this.agentConfig);
        // Based on interfaces. Need to register which class to use
        this.container.registerInstance(constants_1.InjectionSymbols.Logger, this.logger);
        this.container.register(constants_1.InjectionSymbols.Wallet, { useToken: IndyWallet_1.IndyWallet });
        this.container.registerSingleton(constants_1.InjectionSymbols.StorageService, IndyStorageService_1.IndyStorageService);
        this.container.registerSingleton(constants_1.InjectionSymbols.MessageRepository, InMemoryMessageRepository_1.InMemoryMessageRepository);
        this.logger.info('Creating agent with config', Object.assign(Object.assign({}, initialConfig), { 
            // Prevent large object being logged.
            // Will display true/false to indicate if value is present in config
            logger: initialConfig.logger != undefined }));
        if (!this.agentConfig.walletConfig) {
            this.logger.warn('Wallet config has not been set on the agent config. ' +
                'Make sure to initialize the wallet yourself before initializing the agent, ' +
                'or provide the required wallet configuration in the agent constructor');
        }
        // Resolve instances after everything is registered
        this.eventEmitter = this.container.resolve(EventEmitter_1.EventEmitter);
        this.messageSender = this.container.resolve(MessageSender_1.MessageSender);
        this.messageReceiver = this.container.resolve(MessageReceiver_1.MessageReceiver);
        this.transportService = this.container.resolve(TransportService_1.TransportService);
        this.wallet = this.container.resolve(constants_1.InjectionSymbols.Wallet);
        // We set the modules in the constructor because that allows to set them as read-only
        this.connections = this.container.resolve(ConnectionsModule_1.ConnectionsModule);
        this.credentials = this.container.resolve(CredentialsModule_1.CredentialsModule);
        this.proofs = this.container.resolve(ProofsModule_1.ProofsModule);
        this.mediator = this.container.resolve(MediatorModule_1.MediatorModule);
        this.mediationRecipient = this.container.resolve(RecipientModule_1.RecipientModule);
        this.basicMessages = this.container.resolve(BasicMessagesModule_1.BasicMessagesModule);
        this.ledger = this.container.resolve(LedgerModule_1.LedgerModule);
        this.discovery = this.container.resolve(discover_features_1.DiscoverFeaturesModule);
        // Listen for new messages (either from transports or somewhere else in the framework / extensions)
        this.messageSubscription = this.eventEmitter
            .observable(Events_1.AgentEventTypes.AgentMessageReceived)
            .pipe(operators_1.takeUntil(this.agentConfig.stop$), operators_1.concatMap((e) => this.messageReceiver.receiveMessage(e.payload.message)))
            .subscribe();
    }
    registerInboundTransport(inboundTransport) {
        this.messageReceiver.registerInboundTransport(inboundTransport);
    }
    get inboundTransports() {
        return this.messageReceiver.inboundTransports;
    }
    registerOutboundTransport(outboundTransport) {
        this.messageSender.registerOutboundTransport(outboundTransport);
    }
    get outboundTransports() {
        return this.messageSender.outboundTransports;
    }
    get events() {
        return this.eventEmitter;
    }
    get isInitialized() {
        return this._isInitialized && this.wallet.isInitialized;
    }
    async initialize() {
        const { publicDidSeed, walletConfig, mediatorConnectionsInvite } = this.agentConfig;
        if (this._isInitialized) {
            throw new error_1.AriesFrameworkError('Agent already initialized. Currently it is not supported to re-initialize an already initialized agent.');
        }
        if (!this.wallet.isInitialized && walletConfig) {
            await this.wallet.initialize(walletConfig);
        }
        else if (!this.wallet.isInitialized) {
            throw new error_2.WalletError('Wallet config has not been set on the agent config. ' +
                'Make sure to initialize the wallet yourself before initializing the agent, ' +
                'or provide the required wallet configuration in the agent constructor');
        }
        if (publicDidSeed) {
            // If an agent has publicDid it will be used as routing key.
            await this.wallet.initPublicDid({ seed: publicDidSeed });
        }
        for (const transport of this.inboundTransports) {
            transport.start(this);
        }
        for (const transport of this.outboundTransports) {
            transport.start(this);
        }
        // Connect to mediator through provided invitation if provided in config
        // Also requests mediation ans sets as default mediator
        // Because this requires the connections module, we do this in the agent constructor
        if (mediatorConnectionsInvite) {
            await this.mediationRecipient.provision(mediatorConnectionsInvite);
        }
        await this.mediationRecipient.initialize();
        this._isInitialized = true;
    }
    async shutdown() {
        // All observables use takeUntil with the stop$ observable
        // this means all observables will stop running if a value is emitted on this observable
        this.agentConfig.stop$.next(true);
        // Stop transports
        for (const transport of this.outboundTransports) {
            transport.stop();
        }
        for (const transport of this.inboundTransports) {
            transport.stop();
        }
        // close wallet if still initialized
        if (this.wallet.isInitialized) {
            await this.wallet.close();
        }
    }
    get publicDid() {
        return this.wallet.publicDid;
    }
    async receiveMessage(inboundMessage, session) {
        return await this.messageReceiver.receiveMessage(inboundMessage, session);
    }
    get injectionContainer() {
        return this.container;
    }
    get config() {
        return this.agentConfig;
    }
}
exports.Agent = Agent;
//# sourceMappingURL=Agent.js.map
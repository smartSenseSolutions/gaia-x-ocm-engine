"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDidCommTransportQueue = exports.MessageSender = void 0;
const tsyringe_1 = require("tsyringe");
const constants_1 = require("../constants");
const TransportDecorator_1 = require("../decorators/transport/TransportDecorator");
const error_1 = require("../error");
const MessageValidator_1 = require("../utils/MessageValidator");
const EnvelopeService_1 = require("./EnvelopeService");
const TransportService_1 = require("./TransportService");
let MessageSender = class MessageSender {
    constructor(envelopeService, transportService, messageRepository, logger) {
        this.outboundTransports = [];
        this.envelopeService = envelopeService;
        this.transportService = transportService;
        this.messageRepository = messageRepository;
        this.logger = logger;
        this.outboundTransports = [];
    }
    registerOutboundTransport(outboundTransport) {
        this.outboundTransports.push(outboundTransport);
    }
    async packMessage({ keys, message, endpoint, }) {
        const encryptedMessage = await this.envelopeService.packMessage(message, keys);
        return {
            payload: encryptedMessage,
            responseRequested: message.hasAnyReturnRoute(),
            endpoint,
        };
    }
    async sendMessageToSession(session, message) {
        this.logger.debug(`Existing ${session.type} transport session has been found.`, {
            keys: session.keys,
        });
        if (!session.keys) {
            throw new error_1.AriesFrameworkError(`There are no keys for the given ${session.type} transport session.`);
        }
        const encryptedMessage = await this.envelopeService.packMessage(message, session.keys);
        await session.send(encryptedMessage);
    }
    async sendPackage({ connection, encryptedMessage, options, }) {
        var e_1, _a;
        var _b;
        const errors = [];
        // Try to send to already open session
        const session = this.transportService.findSessionByConnectionId(connection.id);
        if ((_b = session === null || session === void 0 ? void 0 : session.inboundMessage) === null || _b === void 0 ? void 0 : _b.hasReturnRouting()) {
            try {
                await session.send(encryptedMessage);
                return;
            }
            catch (error) {
                errors.push(error);
                this.logger.debug(`Sending packed message via session failed with error: ${error.message}.`, error);
            }
        }
        // Retrieve DIDComm services
        const { services, queueService } = await this.retrieveServicesByConnection(connection, options === null || options === void 0 ? void 0 : options.transportPriority);
        if (this.outboundTransports.length === 0 && !queueService) {
            throw new error_1.AriesFrameworkError('Agent has no outbound transport!');
        }
        try {
            // Loop trough all available services and try to send the message
            for (var services_1 = __asyncValues(services), services_1_1; services_1_1 = await services_1.next(), !services_1_1.done;) {
                const service = services_1_1.value;
                this.logger.debug(`Sending outbound message to service:`, { service });
                try {
                    for (const transport of this.outboundTransports) {
                        if (transport.supportedSchemes.includes(service.protocolScheme)) {
                            await transport.sendMessage({
                                payload: encryptedMessage,
                                endpoint: service.serviceEndpoint,
                                connectionId: connection.id,
                            });
                            break;
                        }
                    }
                    return;
                }
                catch (error) {
                    this.logger.debug(`Sending outbound message to service with id ${service.id} failed with the following error:`, {
                        message: error.message,
                        error: error,
                    });
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (services_1_1 && !services_1_1.done && (_a = services_1.return)) await _a.call(services_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // We didn't succeed to send the message over open session, or directly to serviceEndpoint
        // If the other party shared a queue service endpoint in their did doc we queue the message
        if (queueService) {
            this.logger.debug(`Queue packed message for connection ${connection.id} (${connection.theirLabel})`);
            this.messageRepository.add(connection.id, encryptedMessage);
            return;
        }
        // Message is undeliverable
        this.logger.error(`Message is undeliverable to connection ${connection.id} (${connection.theirLabel})`, {
            message: encryptedMessage,
            errors,
            connection,
        });
        throw new error_1.AriesFrameworkError(`Message is undeliverable to connection ${connection.id} (${connection.theirLabel})`);
    }
    async sendMessage(outboundMessage, options) {
        var e_2, _a;
        var _b;
        const { connection, payload } = outboundMessage;
        const errors = [];
        this.logger.debug('Send outbound message', {
            message: payload,
            connectionId: connection.id,
        });
        // Try to send to already open session
        const session = this.transportService.findSessionByConnectionId(connection.id);
        if ((_b = session === null || session === void 0 ? void 0 : session.inboundMessage) === null || _b === void 0 ? void 0 : _b.hasReturnRouting(payload.threadId)) {
            this.logger.debug(`Found session with return routing for message '${payload.id}' (connection '${connection.id}'`);
            try {
                await this.sendMessageToSession(session, payload);
                return;
            }
            catch (error) {
                errors.push(error);
                this.logger.debug(`Sending an outbound message via session failed with error: ${error.message}.`, error);
            }
        }
        // Retrieve DIDComm services
        const { services, queueService } = await this.retrieveServicesByConnection(connection, options === null || options === void 0 ? void 0 : options.transportPriority);
        try {
            // Loop trough all available services and try to send the message
            for (var services_2 = __asyncValues(services), services_2_1; services_2_1 = await services_2.next(), !services_2_1.done;) {
                const service = services_2_1.value;
                try {
                    // Enable return routing if the
                    const shouldUseReturnRoute = !this.transportService.hasInboundEndpoint(connection.didDoc);
                    await this.sendMessageToService({
                        message: payload,
                        service,
                        senderKey: connection.verkey,
                        returnRoute: shouldUseReturnRoute,
                        connectionId: connection.id,
                    });
                    return;
                }
                catch (error) {
                    errors.push(error);
                    this.logger.debug(`Sending outbound message to service with id ${service.id} failed with the following error:`, {
                        message: error.message,
                        error: error,
                    });
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (services_2_1 && !services_2_1.done && (_a = services_2.return)) await _a.call(services_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // We didn't succeed to send the message over open session, or directly to serviceEndpoint
        // If the other party shared a queue service endpoint in their did doc we queue the message
        if (queueService) {
            this.logger.debug(`Queue message for connection ${connection.id} (${connection.theirLabel})`);
            const keys = {
                recipientKeys: queueService.recipientKeys,
                routingKeys: queueService.routingKeys || [],
                senderKey: connection.verkey,
            };
            const encryptedMessage = await this.envelopeService.packMessage(payload, keys);
            this.messageRepository.add(connection.id, encryptedMessage);
            return;
        }
        // Message is undeliverable
        this.logger.error(`Message is undeliverable to connection ${connection.id} (${connection.theirLabel})`, {
            message: payload,
            errors,
            connection,
        });
        throw new error_1.AriesFrameworkError(`Message is undeliverable to connection ${connection.id} (${connection.theirLabel})`);
    }
    async sendMessageToService({ message, service, senderKey, returnRoute, connectionId, }) {
        if (this.outboundTransports.length === 0) {
            throw new error_1.AriesFrameworkError('Agent has no outbound transport!');
        }
        this.logger.debug(`Sending outbound message to service:`, { messageId: message.id, service });
        const keys = {
            recipientKeys: service.recipientKeys,
            routingKeys: service.routingKeys || [],
            senderKey,
        };
        // Set return routing for message if requested
        if (returnRoute) {
            message.setReturnRouting(TransportDecorator_1.ReturnRouteTypes.all);
        }
        try {
            await MessageValidator_1.MessageValidator.validate(message);
        }
        catch (error) {
            this.logger.error(`Aborting sending outbound message ${message.type} to ${service.serviceEndpoint}. Message validation failed`, {
                errors: error,
                message: message.toJSON(),
            });
            throw error;
        }
        const outboundPackage = await this.packMessage({ message, keys, endpoint: service.serviceEndpoint });
        outboundPackage.endpoint = service.serviceEndpoint;
        outboundPackage.connectionId = connectionId;
        for (const transport of this.outboundTransports) {
            if (transport.supportedSchemes.includes(service.protocolScheme)) {
                await transport.sendMessage(outboundPackage);
                break;
            }
        }
    }
    async retrieveServicesByConnection(connection, transportPriority) {
        this.logger.debug(`Retrieving services for connection '${connection.id}' (${connection.theirLabel})`, {
            transportPriority,
        });
        // Retrieve DIDComm services
        const allServices = this.transportService.findDidCommServices(connection);
        //Separate queue service out
        let services = allServices.filter((s) => !isDidCommTransportQueue(s.serviceEndpoint));
        const queueService = allServices.find((s) => isDidCommTransportQueue(s.serviceEndpoint));
        //If restrictive will remove services not listed in schemes list
        if (transportPriority === null || transportPriority === void 0 ? void 0 : transportPriority.restrictive) {
            services = services.filter((service) => {
                const serviceSchema = service.protocolScheme;
                return transportPriority.schemes.includes(serviceSchema);
            });
        }
        //If transport priority is set we will sort services by our priority
        if (transportPriority === null || transportPriority === void 0 ? void 0 : transportPriority.schemes) {
            services = services.sort(function (a, b) {
                const aScheme = a.protocolScheme;
                const bScheme = b.protocolScheme;
                return (transportPriority === null || transportPriority === void 0 ? void 0 : transportPriority.schemes.indexOf(aScheme)) - (transportPriority === null || transportPriority === void 0 ? void 0 : transportPriority.schemes.indexOf(bScheme));
            });
        }
        this.logger.debug(`Retrieved ${services.length} services for message to connection '${connection.id}'(${connection.theirLabel})'`);
        return { services, queueService };
    }
};
MessageSender = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __param(2, tsyringe_1.inject(constants_1.InjectionSymbols.MessageRepository)),
    __param(3, tsyringe_1.inject(constants_1.InjectionSymbols.Logger)),
    __metadata("design:paramtypes", [EnvelopeService_1.EnvelopeService,
        TransportService_1.TransportService, Object, Object])
], MessageSender);
exports.MessageSender = MessageSender;
function isDidCommTransportQueue(serviceEndpoint) {
    return serviceEndpoint === constants_1.DID_COMM_TRANSPORT_QUEUE;
}
exports.isDidCommTransportQueue = isDidCommTransportQueue;
//# sourceMappingURL=MessageSender.js.map